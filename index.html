<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DEEP SEA SYMBIOSIS | The Cycle</title>
    <style>
        :root {
            --accent: #00ffff;
            --bg: #000510;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-user-select: none;
            user-select: none;
        }

        body,
        html {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: var(--bg);
            font-family: "Optima", "BIZ UDPMincho", serif;
            color: white;
        }

        #canvas-container {
            position: absolute;
            inset: 0;
            z-index: 1;
        }

        /* UI Layers */
        #ui-layer {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            pointer-events: none;
            z-index: 10;
            padding: 2rem;
        }

        .pane {
            pointer-events: auto;
        }

        #top-ui {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        #title-area {
            text-align: left;
        }

        h1 {
            font-size: 1.2rem;
            letter-spacing: 0.5rem;
            color: var(--accent);
            opacity: 0.8;
            text-shadow: 0 0 10px var(--accent);
        }

        p.subtitle {
            font-size: 0.8rem;
            letter-spacing: 0.2rem;
            opacity: 0.6;
            margin-top: 0.5rem;
        }

        #controls {
            display: flex;
            gap: 1rem;
        }

        .btn-circle {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            border: 1px solid rgba(0, 255, 255, 0.3);
            background: rgba(0, 5, 16, 0.6);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: 0.3s;
        }

        .btn-circle:hover {
            border-color: var(--accent);
            box-shadow: 0 0 15px var(--accent);
        }

        .btn-circle svg {
            width: 20px;
            height: 20px;
            fill: var(--accent);
        }

        #bottom-ui {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }

        #hint-text {
            font-size: 0.9rem;
            letter-spacing: 0.3rem;
            opacity: 0.5;
            animation: breathe 4s infinite;
        }

        #draw-btn {
            padding: 1rem 3rem;
            border-radius: 2rem;
            border: 1px solid var(--accent);
            background: rgba(0, 255, 255, 0.1);
            color: var(--accent);
            font-size: 1rem;
            letter-spacing: 0.5rem;
            cursor: pointer;
            transition: 0.3s;
            text-transform: uppercase;
        }

        #draw-btn:hover {
            background: var(--accent);
            color: var(--bg);
            box-shadow: 0 0 30px var(--accent);
        }

        /* Drawing Overlay */
        #drawing-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 5, 16, 0.8);
            display: none;
            z-index: 20;
            cursor: crosshair;
        }

        #drawing-overlay.active {
            display: block;
        }

        #drawing-canvas {
            width: 100%;
            height: 100%;
        }

        #draw-instructions {
            position: absolute;
            top: 10%;
            width: 100%;
            text-align: center;
            font-size: 1rem;
            letter-spacing: 0.4rem;
            color: var(--accent);
        }

        @keyframes breathe {

            0%,
            100% {
                opacity: 0.3;
                transform: scale(0.98);
            }

            50% {
                opacity: 0.8;
                transform: scale(1);
            }
        }

        /* Sound Icon Placeholder */
        .sound-off line {
            display: none;
        }
    </style>
</head>

<body>
    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div id="top-ui" class="pane">
            <div id="title-area">
                <h1>深海のサイクル</h1>
                <p class="subtitle">SYMBIOSIS OF THE ABYSS</p>
            </div>
            <div id="controls">
                <div class="btn-circle" id="reset-btn" title="Reset ecosystem">
                    <svg viewBox="0 0 24 24">
                        <path
                            d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z" />
                    </svg>
                </div>
                <div class="btn-circle" id="sound-btn" title="Toggle Sound">
                    <svg viewBox="0 0 24 24" id="sound-icon">
                        <path
                            d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z" />
                    </svg>
                </div>
            </div>
        </div>
        <div id="bottom-ui" class="pane">
            <div id="hint-text">海は静かに、あなたの筆跡を待っている</div>
            <button id="draw-btn">生命を創る</button>
        </div>
    </div>

    <div id="drawing-overlay">
        <div id="draw-instructions">一本の線を、一息に描いてください</div>
        <canvas id="drawing-canvas"></canvas>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        (function () {
            if (typeof THREE === 'undefined') return;

            // --- CONFIG ---
            const COLORS = [0x00ffff, 0xff00ff, 0x007fff, 0x7fff00, 0xffff00];
            const MAX_CREATURES = 100;

            // --- STATE ---
            let isDrawingMode = false;
            let isMuted = true;

            // --- THREEJS BASE ---
            let scene, camera, renderer, clock;
            let creatures = [];
            let particles, godRays;

            let fadeMesh;

            function initScene() {
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
                camera.position.set(0, 0, 40);

                renderer = new THREE.WebGLRenderer({ antialias: false, alpha: false }); // Disable antialias for trail stability
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.autoClear = false; // For trails
                document.getElementById('canvas-container').appendChild(renderer.domElement);

                // Fading Quad for Trails
                const fadeGeo = new THREE.PlaneGeometry(2, 2);
                const fadeMat = new THREE.MeshBasicMaterial({ color: 0x000510, transparent: true, opacity: 0.1 });
                fadeMesh = new THREE.Mesh(fadeGeo, fadeMat);
                fadeMesh.material.depthTest = false;
                fadeMesh.material.depthWrite = false;

                clock = new THREE.Clock();
                addEnvironment();
                animate();
            }

            function addEnvironment() {
                // Marine Snow
                const count = 2000;
                const geo = new THREE.BufferGeometry();
                const pos = new Float32Array(count * 3);
                for (let i = 0; i < count * 3; i++) pos[i] = (Math.random() - 0.5) * 100;
                geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                const mat = new THREE.PointsMaterial({ color: 0x00ffff, size: 0.1, transparent: true, opacity: 0.3 });
                particles = new THREE.Points(geo, mat);
                scene.add(particles);

                // God Rays
                const rayGeo = new THREE.PlaneGeometry(100, 100);
                const rayMat = new THREE.ShaderMaterial({
                    uniforms: { uTime: { value: 0 } },
                    vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
                    fragmentShader: `
                        uniform float uTime;
                        varying vec2 vUv;
                        void main() {
                            float b = sin(vUv.x * 10.0 + uTime * 0.5) * 0.5 + 0.5;
                            float a = (1.0 - vUv.y) * 0.1 * b;
                            gl_FragColor = vec4(0.0, 0.8, 1.0, a);
                        }
                    `,
                    transparent: true, blending: THREE.AdditiveBlending, side: THREE.DoubleSide
                });
                godRays = new THREE.Mesh(rayGeo, rayMat);
                godRays.position.y = 50;
                godRays.rotation.x = Math.PI / 2.5;
                scene.add(godRays);
            }

            // --- CAMERA INTERACTION ---
            let targetRotX = 0, targetRotY = 0;
            let currentRotX = 0, currentRotY = 0;
            let targetZoom = 40, currentZoom = 40;
            let isDragging = false, lastMouseX = 0, lastMouseY = 0;

            function initInteraction() {
                window.addEventListener('mousedown', (e) => {
                    if (isDrawingMode) return;
                    isDragging = true;
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                });
                window.addEventListener('mousemove', (e) => {
                    if (!isDragging || isDrawingMode) return;
                    const dx = e.clientX - lastMouseX;
                    const dy = e.clientY - lastMouseY;
                    targetRotY += dx * 0.005;
                    targetRotX += dy * 0.005;
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                });
                window.addEventListener('mouseup', () => isDragging = false);
                window.addEventListener('wheel', (e) => {
                    if (isDrawingMode) return;
                    targetZoom = THREE.MathUtils.clamp(targetZoom + e.deltaY * 0.05, 10, 100);
                });

                // UI Events
                document.getElementById('draw-btn').onclick = () => toggleDrawingMode(true);
                document.getElementById('reset-btn').onclick = resetEcosystem;
                document.getElementById('sound-btn').onclick = toggleSound;

                initDrawingCanvas();
            }

            function updateCamera() {
                currentRotX = THREE.MathUtils.lerp(currentRotX, targetRotX, 0.05);
                currentRotY = THREE.MathUtils.lerp(currentRotY, targetRotY, 0.05);
                currentZoom = THREE.MathUtils.lerp(currentZoom, targetZoom, 0.05);

                const phi = currentRotX;
                const theta = currentRotY;
                camera.position.x = currentZoom * Math.sin(theta) * Math.cos(phi);
                camera.position.y = currentZoom * Math.sin(phi);
                camera.position.z = currentZoom * Math.cos(theta) * Math.cos(phi);
                camera.lookAt(0, 0, 0);
            }


            // --- CREATURE CLASS ---
            class Creature {
                constructor(points, type, color, scene) {
                    this.scene = scene;
                    this.type = type; // 'dart', 'eel', 'float'
                    this.color = new THREE.Color(color);
                    this.energy = 1.0;
                    this.age = 0;
                    this.maxAge = 15 + Math.random() * 20;

                    // AI Params based on type
                    this.maxSpeed = type === 'dart' ? 0.4 : (type === 'eel' ? 0.2 : 0.1);
                    this.steerForce = type === 'dart' ? 0.05 : 0.02;

                    // State
                    this.pos = points[0].clone();
                    this.vel = new THREE.Vector3((Math.random() - 0.5) * 0.1, (Math.random() - 0.5) * 0.1, (Math.random() - 0.5) * 0.1);
                    this.acc = new THREE.Vector3();

                    // Trail/Skeleton (Keep original points as seed or reference)
                    this.segments = type === 'eel' ? 50 : 25;
                    this.history = [];
                    for (let i = 0; i < this.segments; i++) this.history.push(this.pos.clone());

                    // Mesh
                    this.initMesh();
                }

                initMesh() {
                    this.geometry = new THREE.BufferGeometry();
                    const vertices = new Float32Array(this.segments * 2 * 3);
                    const uvs = new Float32Array(this.segments * 2 * 2);
                    this.geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                    this.geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));

                    this.material = new THREE.ShaderMaterial({
                        uniforms: {
                            uColor: { value: this.color },
                            uEnergy: { value: this.energy },
                            uTime: { value: 0 },
                            uType: { value: this.type === 'dart' ? 0 : (this.type === 'eel' ? 1 : 2) }
                        },
                        vertexShader: `
                            varying vec2 vUv;
                            void main() {
                                vUv = uv;
                                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            }
                        `,
                        fragmentShader: `
                            uniform vec3 uColor;
                            uniform float uEnergy;
                            uniform float uTime;
                            uniform float uType;
                            varying vec2 vUv;
                            void main() {
                                float glow = pow(1.0 - abs(vUv.y - 0.5) * 2.0, 4.0);
                                float taper = 1.0 - vUv.x;
                                
                                // Organic pulsing
                                float pulse = 0.7 + 0.3 * sin(uTime * 3.0 + vUv.x * 10.0);
                                if(uType > 1.5) pulse = 0.7 + 0.3 * sin(uTime * 1.5 + vUv.x * 5.0); // Jellyfish slow pulse
                                
                                vec3 finalColor = mix(uColor, vec3(1.0), glow * 0.5);
                                float alpha = glow * uEnergy * pulse * taper;
                                
                                gl_FragColor = vec4(finalColor, alpha);
                            }
                        `,
                        transparent: true, blending: THREE.AdditiveBlending, side: THREE.DoubleSide, depthWrite: false
                    });

                    this.mesh = new THREE.Mesh(this.geometry, this.material);
                    this.scene.add(this.mesh);
                }

                update(time, delta, others) {
                    this.age += delta;
                    this.energy = Math.max(0, 1.0 - this.age / this.maxAge);

                    // --- AI BEHAVIORS ---
                    this.wander();
                    this.flock(others); // Schooling + Predation/Avoidance

                    this.vel.add(this.acc);
                    this.vel.clampLength(0.01, this.maxSpeed);
                    this.pos.add(this.vel);
                    this.acc.multiplyScalar(0);

                    // Bound checking
                    const limit = 60;
                    if (Math.abs(this.pos.x) > limit) this.acc.x -= this.pos.x * 0.01;
                    if (Math.abs(this.pos.y) > limit) this.acc.y -= this.pos.y * 0.01;
                    if (Math.abs(this.pos.z) > limit) this.acc.z -= this.pos.z * 0.01;

                    // Update Trail
                    this.history.unshift(this.pos.clone());
                    if (this.history.length > this.segments) this.history.pop();

                    // Update Geometry
                    const attr = this.geometry.attributes.position;
                    // Scale thickness by energy (fade out as they die)
                    const baseThickness = (this.type === 'eel' ? 0.4 : (this.type === 'float' ? 0.8 : 0.2)) * Math.sqrt(this.energy);

                    for (let i = 0; i < this.segments; i++) {
                        const p = this.history[i];
                        const prev = i > 0 ? this.history[i - 1] : (i < this.segments - 1 ? this.history[i + 1] : p);

                        const direction = p.clone().sub(prev).normalize();
                        const normal = new THREE.Vector3(-direction.y, direction.x, 0).normalize();

                        let thickness = baseThickness * (1.0 - i / this.segments);
                        if (this.type === 'float') thickness *= (1.0 + 0.3 * Math.sin(time * 2 + i * 0.5));

                        const pLeft = p.clone().add(normal.clone().multiplyScalar(thickness));
                        const pRight = p.clone().sub(normal.clone().multiplyScalar(thickness));

                        attr.setXYZ(i * 2, pLeft.x, pLeft.y, pLeft.z);
                        attr.setXYZ(i * 2 + 1, pRight.x, pRight.y, pRight.z);
                    }
                    attr.needsUpdate = true;

                    this.material.uniforms.uEnergy.value = this.energy;
                    this.material.uniforms.uTime.value = time;
                }

                wander() {
                    const noise = 0.015;
                    this.acc.add(new THREE.Vector3((Math.random() - 0.5) * noise, (Math.random() - 0.5) * noise, (Math.random() - 0.5) * noise));
                }

                flock(others) {
                    let sepDist = 4.0;
                    let cohDist = 15.0;

                    let sepSteer = new THREE.Vector3();
                    let cohSteer = new THREE.Vector3();
                    let huntSteer = new THREE.Vector3();

                    let sepCount = 0;
                    let cohCount = 0;

                    others.forEach(o => {
                        if (o === this) return;
                        let dist = this.pos.distanceTo(o.pos);

                        // 1. Separation
                        if (dist < sepDist) {
                            sepSteer.add(this.pos.clone().sub(o.pos).normalize().divideScalar(dist));
                            sepCount++;
                        }

                        // 2. Schooling (Cohesion with same color)
                        if (dist < cohDist && o.color.getHex() === this.color.getHex()) {
                            cohSteer.add(o.pos);
                            cohCount++;
                        }

                        // 3. Predation / Avoidance (Eels hunt Darts)
                        if (this.type === 'eel' && o.type === 'dart' && dist < 10.0) {
                            huntSteer.add(o.pos.clone().sub(this.pos).normalize());
                            if (dist < 1.0) o.energy *= 0.8; // Bite!
                        }
                        if (this.type === 'dart' && o.type === 'eel' && dist < 8.0) {
                            sepSteer.add(this.pos.clone().sub(o.pos).normalize().multiplyScalar(2.0));
                            sepCount++;
                        }
                    });

                    if (sepCount > 0) {
                        sepSteer.divideScalar(sepCount).normalize().multiplyScalar(this.maxSpeed).sub(this.vel).clampLength(0, this.steerForce);
                        this.acc.add(sepSteer.multiplyScalar(1.5));
                    }
                    if (cohCount > 0) {
                        cohSteer.divideScalar(cohCount).sub(this.pos).normalize().multiplyScalar(this.maxSpeed).sub(this.vel).clampLength(0, this.steerForce);
                        this.acc.add(cohSteer.multiplyScalar(0.5));
                    }
                    if (huntSteer.length() > 0) {
                        this.acc.add(huntSteer.normalize().multiplyScalar(this.steerForce * 2.0));
                    }
                }

                isDead() { return this.energy <= 0; }
                destroy() {
                    this.scene.remove(this.mesh);
                    this.geometry.dispose();
                    this.material.dispose();
                }
            }

            // --- AUDIO LOGIC ---
            let audioCtx, oscillator, gainNode;
            function toggleSound() {
                if (!audioCtx) {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    oscillator = audioCtx.createOscillator();
                    gainNode = audioCtx.createGain();
                    oscillator.type = 'sine';
                    oscillator.frequency.value = 40; // Deep hum
                    gainNode.gain.value = 0.05;
                    oscillator.connect(gainNode);
                    gainNode.connect(audioCtx.destination);
                    oscillator.start();
                }

                isMuted = !isMuted;
                if (isMuted) gainNode.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
                else gainNode.gain.setTargetAtTime(0.05, audioCtx.currentTime, 0.1);

                document.getElementById('sound-icon').classList.toggle('sound-off', isMuted);
            }

            // --- DRAWING LOGIC ---
            let dCanvas, dCtx, stroke = [];
            function initDrawingCanvas() {
                dCanvas = document.getElementById('drawing-canvas');
                dCtx = dCanvas.getContext('2d');
                resizeDrawingCanvas();
                window.addEventListener('resize', resizeDrawingCanvas);

                const start = (x, y) => { stroke = [{ x: x, y: y, t: Date.now() }]; };
                const move = (x, y) => {
                    if (stroke.length === 0) return;
                    stroke.push({ x: x, y: y, t: Date.now() });
                    drawStroke();
                };
                const end = () => {
                    if (stroke.length > 5) createLifeFromStroke(stroke);
                    stroke = [];
                    toggleDrawingMode(false);
                };

                dCanvas.onmousedown = (e) => start(e.clientX, e.clientY);
                dCanvas.onmousemove = (e) => move(e.clientX, e.clientY);
                dCanvas.onmouseup = end;

                dCanvas.addEventListener('touchstart', (e) => { e.preventDefault(); start(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
                dCanvas.addEventListener('touchmove', (e) => { e.preventDefault(); move(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
                dCanvas.addEventListener('touchend', (e) => { e.preventDefault(); end(); }, { passive: false });
            }

            function resizeDrawingCanvas() {
                dCanvas.width = window.innerWidth;
                dCanvas.height = window.innerHeight;
            }

            function drawStroke() {
                dCtx.clearRect(0, 0, dCanvas.width, dCanvas.height);
                dCtx.beginPath();
                const grad = dCtx.createLinearGradient(stroke[0].x, stroke[0].y, stroke[stroke.length - 1].x, stroke[stroke.length - 1].y);
                grad.addColorStop(0, '#00ffff');
                grad.addColorStop(1, '#ffffff');
                dCtx.strokeStyle = grad;
                dCtx.lineWidth = 4;
                dCtx.lineCap = 'round';
                dCtx.lineJoin = 'round';
                dCtx.shadowBlur = 10;
                dCtx.shadowColor = '#00ffff';
                dCtx.moveTo(stroke[0].x, stroke[0].y);
                for (let i = 1; i < stroke.length; i++) dCtx.lineTo(stroke[i].x, stroke[i].y);
                dCtx.stroke();
            }

            function toggleDrawingMode(active) {
                isDrawingMode = active;
                document.getElementById('drawing-overlay').classList.toggle('active', active);
                if (!active) dCtx.clearRect(0, 0, dCanvas.width, dCanvas.height);
            }

            function createLifeFromStroke(points) {
                // Analysis
                const start = points[0];
                const end = points[points.length - 1];
                const duration = end.t - start.t;
                const pathLength = points.reduce((acc, p, i) => i === 0 ? 0 : acc + Math.sqrt((p.x - points[i - 1].x) ** 2 + (p.y - points[i - 1].y) ** 2), 0);
                const straightDist = Math.sqrt((end.x - start.x) ** 2 + (end.y - start.y) ** 2);
                const curvature = pathLength / (straightDist || 1);
                const avgSpeed = pathLength / (duration || 1);

                // Determine Archetype
                let type = 'dart';
                if (curvature > 2.0 && pathLength > 200) type = 'eel';
                else if (avgSpeed < 0.5 && pathLength > 100) type = 'float';

                // Convert Screen Points to 3D World Points for seed
                const worldPoints = points.map(p => {
                    const vec = new THREE.Vector3((p.x / window.innerWidth) * 2 - 1, -(p.y / window.innerHeight) * 2 + 1, 0.5);
                    vec.unproject(camera);
                    const dir = vec.sub(camera.position).normalize();
                    const distance = -camera.position.z / dir.z; // Project to Z=0 plane
                    return camera.position.clone().add(dir.multiplyScalar(distance));
                });

                const color = COLORS[Math.floor(Math.random() * COLORS.length)];
                const creature = new Creature(worldPoints, type, color, scene);
                creatures.push(creature);

                // Trigger Birth VFX
                createBirthFlash(worldPoints[0], color);
                console.log(`Born: ${type} Speed:${avgSpeed.toFixed(2)} Curv:${curvature.toFixed(2)}`);
            }

            function createBirthFlash(pos, color) {
                const geo = new THREE.RingGeometry(0.1, 0.5, 32);
                const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.8, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(pos);
                mesh.lookAt(camera.position);
                scene.add(mesh);

                let s = 1;
                const animateFlash = () => {
                    s += 0.5;
                    mesh.scale.set(s, s, s);
                    mesh.material.opacity *= 0.9;
                    if (mesh.material.opacity > 0.01) requestAnimationFrame(animateFlash);
                    else {
                        scene.remove(mesh);
                        geo.dispose();
                        mat.dispose();
                    }
                };
                animateFlash();
            }

            function resetEcosystem() {
                console.log("Resetting ecosystem...");
                creatures.forEach(c => scene.remove(c.mesh));
                creatures = [];
            }

            function toggleSound() {
                isMuted = !isMuted;
                document.getElementById('sound-icon').classList.toggle('sound-off', isMuted);
                // Background audio implementation placeholder
            }

            // --- LOOP ---
            function animate() {
                requestAnimationFrame(animate);
                const delta = clock.getDelta();
                const time = clock.getElapsedTime();

                updateCamera();

                // Fading Trail Effect
                if (fadeMesh) {
                    fadeMesh.position.copy(camera.position);
                    fadeMesh.quaternion.copy(camera.quaternion);
                    fadeMesh.translateZ(-1); // Place right in front of camera
                    renderer.render(fadeMesh, camera);
                }

                if (godRays) godRays.material.uniforms.uTime.value = time;
                if (particles) {
                    particles.rotation.y += 0.001;
                    const pos = particles.geometry.attributes.position.array;
                    for (let i = 0; i < pos.length; i += 3) {
                        pos[i + 1] -= 0.02; // Sinking snow
                        if (pos[i + 1] < -50) pos[i + 1] = 50;
                    }
                    particles.geometry.attributes.position.needsUpdate = true;
                }

                // Creatures Update
                for (let i = creatures.length - 1; i >= 0; i--) {
                    const c = creatures[i];
                    c.update(time, delta, creatures);
                    if (c.isDead()) {
                        c.destroy();
                        creatures.splice(i, 1);
                    }
                }

                renderer.render(scene, camera);
            }

            initScene();
            initInteraction();
        })();
    </script>
</body>

</html>