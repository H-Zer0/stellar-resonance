<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STELLAR RESONANCE | Star Cycle</title>
    <link rel="icon" href="icon.png">
    <link rel="apple-touch-icon" href="icon.png">
    <!-- Library: TensorFlow.js (Feature Extraction) -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js"></script>
    <style>
        :root {
            --accent: #ffcc00;
            /* Star Golden */
            --bg: #000208;
            --glass: rgba(10, 20, 40, 0.6);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            overflow: hidden;
        }

        body {
            background: var(--bg);
            font-family: 'Inter', system-ui, sans-serif;
            color: white;
            -webkit-user-select: none;
            user-select: none;
        }

        #ui-overlay {
            position: absolute;
            inset: 0;
            z-index: 100;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 2rem;
        }

        .glass-panel {
            pointer-events: auto;
            background: var(--glass);
            backdrop-filter: blur(25px);
            border: 1px solid rgba(255, 200, 0, 0.2);
            border-radius: 20px;
            padding: 1.5rem;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
        }

        h1 {
            font-size: 1.2rem;
            letter-spacing: 0.5em;
            color: var(--accent);
            text-transform: uppercase;
            text-shadow: 0 0 15px var(--accent);
        }

        #bottom-bar {
            display: flex;
            align-items: center;
            gap: 1.5rem;
            justify-content: center;
        }

        .btn {
            background: rgba(255, 204, 0, 0.1);
            border: 2px solid var(--accent);
            color: var(--accent);
            padding: 1rem 3rem;
            border-radius: 50px;
            cursor: pointer;
            transition: 0.5s;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            font-weight: bold;
            pointer-events: auto;
        }

        .btn:hover {
            background: var(--accent);
            color: var(--bg);
            box-shadow: 0 0 30px var(--accent);
            transform: translateY(-3px);
        }

        /* Sketch Layer */
        #sketch-overlay {
            position: absolute;
            inset: 0;
            z-index: 200;
            background: rgba(0, 5, 15, 0.95);
            display: none;
            cursor: crosshair;
        }

        #sketch-overlay.active {
            display: block;
        }

        #sketch-canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
        }

        #sketch-ui {
            position: absolute;
            bottom: 8%;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 2rem;
            z-index: 210;
        }

        #sketch-hint {
            position: absolute;
            top: 12%;
            width: 100%;
            text-align: center;
            color: var(--accent);
            font-size: 1.4rem;
            pointer-events: none;
            letter-spacing: 0.4rem;
            z-index: 210;
        }

        #mass-control {
            width: 300px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
        }

        #mass-slider {
            width: 100%;
            cursor: pointer;
            accent-color: var(--accent);
        }

        #mass-label {
            color: var(--accent);
            font-weight: bold;
            font-family: monospace;
            font-size: 0.9rem;
            text-shadow: 0 0 10px var(--accent);
        }

        #sketch-ui-panel {
            position: absolute;
            bottom: 5%;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 220;
            background: rgba(0, 5, 20, 0.7);
            backdrop-filter: blur(20px);
            padding: 2rem;
            border-radius: 30px;
            border: 1px solid rgba(255, 204, 0, 0.3);
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.8);
            pointer-events: auto;
        }

        #sketch-button-container {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }
    </style>
</head>

<body>

    <div id="ui-overlay">
        <div id="top-bar" class="glass-panel">
            <h1>Stellar Resonance</h1>
            <div id="stats" style="font-family: monospace; font-size: 1.2rem; color: var(--accent);">STARS: 0</div>
        </div>
        <div id="bottom-bar">
            <button class="btn" id="open-sketch-btn">星を描く</button>
            <button class="btn" id="sound-toggle-btn">SOUND: OFF</button>
        </div>
    </div>

    <div id="sketch-overlay">
        <div id="sketch-hint">星の核（形）を描いてください</div>

        <div id="sketch-ui-panel">
            <div id="mass-control">
                <div id="mass-label">質量: 普通 (恒星)</div>
                <input type="range" id="mass-slider" min="5" max="45" value="18">
            </div>

            <div id="sketch-button-container">
                <button class="btn" id="confirm-sketch-btn">誕生</button>
                <button class="btn" id="clear-sketch-btn">修正</button>
                <button class="btn" id="close-sketch-btn">戻る</button>
            </div>
        </div>
        <canvas id="sketch-canvas"></canvas>
    </div>

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>

    <script>
        /**
         * STELLAR RESONANCE | Star Cycle Simulator
         * Adaptation from Deep Sea Symbiosis Theme.
         */

        class Simulation {
            constructor() {
                this.stars = [];
                this.isMuted = true;

                this.initThree();
                this.initPhysics();
                this.initSketchLayer();
                this.animate();
            }

            initThree() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x000208, 0.002);

                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 3000);
                this.camera.position.set(0, 100, 300);

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.setClearColor(0x000208);
                document.body.appendChild(this.renderer.domElement);

                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;

                // --- ライティング ---
                this.scene.add(new THREE.AmbientLight(0x203050, 0.6));
                const sun = new THREE.DirectionalLight(0xffffff, 0.8);
                sun.position.set(100, 200, 100);
                this.scene.add(sun);

                // Bloom Post-processing (星の輝きに必須)
                const renderScene = new THREE.RenderPass(this.scene, this.camera);
                this.bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 2.0, 0.4, 0.85);
                this.bloomPass.threshold = 0.1;
                this.bloomPass.strength = 2.0;
                this.bloomPass.radius = 0.5;

                this.composer = new THREE.EffectComposer(this.renderer);
                this.composer.addPass(renderScene);
                this.composer.addPass(this.bloomPass);

                this.addStarfield();
            }

            addStarfield() {
                const geo = new THREE.BufferGeometry();
                const pos = new Float32Array(10000 * 3);
                const col = new Float32Array(10000 * 3);
                for (let i = 0; i < 10000; i++) {
                    pos[i * 3] = (Math.random() - 0.5) * 1500;
                    pos[i * 3 + 1] = (Math.random() - 0.5) * 1500;
                    pos[i * 3 + 2] = (Math.random() - 0.5) * 1500;
                    col[i * 3] = col[i * 3 + 1] = col[i * 3 + 2] = 0.5 + Math.random() * 0.5;
                }
                geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                geo.setAttribute('color', new THREE.BufferAttribute(col, 3));
                const mat = new THREE.PointsMaterial({ size: 1.0, vertexColors: true, transparent: true, opacity: 0.6 });
                this.scene.add(new THREE.Points(geo, mat));
            }

            initPhysics() {
                this.clock = new THREE.Clock();
            }

            initSketchLayer() {
                const overlay = document.getElementById('sketch-overlay');
                const canvas = document.getElementById('sketch-canvas');
                const ctx = canvas.getContext('2d');
                const massSlider = document.getElementById('mass-slider');
                const massLabel = document.getElementById('mass-label');
                let points = [];
                let isDrawing = false;

                const updateMassLabel = () => {
                    const val = parseInt(massSlider.value);
                    let type = "";
                    if (val < 12) type = "小型星 (白色矮星へ)";
                    else if (val < 22) type = "標準星 (赤色巨星へ)";
                    else if (val < 32) type = "巨大星 (超新星爆発へ)";
                    else type = "超巨大星 (ブラックホールへ)";
                    massLabel.innerText = `質量: ${val} - ${type}`;
                };
                massSlider.oninput = updateMassLabel;
                updateMassLabel();

                const resize = () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; };
                window.addEventListener('resize', resize);
                resize();

                document.getElementById('open-sketch-btn').onclick = () => {
                    overlay.classList.add('active');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    points = [];
                };

                document.getElementById('close-sketch-btn').onclick = () => overlay.classList.remove('active');
                document.getElementById('clear-sketch-btn').onclick = () => { ctx.clearRect(0, 0, canvas.width, canvas.height); points = []; };

                canvas.onpointerdown = (e) => { isDrawing = true; points.push([e.clientX, e.clientY]); };
                canvas.onpointermove = (e) => {
                    if (!isDrawing) return;
                    const last = points[points.length - 1];
                    ctx.beginPath();
                    ctx.strokeStyle = '#ffcc00';
                    ctx.lineWidth = 4;
                    ctx.lineCap = 'round';
                    ctx.moveTo(last[0], last[1]);
                    ctx.lineTo(e.clientX, e.clientY);
                    ctx.stroke();
                    points.push([e.clientX, e.clientY]);
                };
                canvas.onpointerup = () => isDrawing = false;

                document.getElementById('confirm-sketch-btn').onclick = () => {
                    if (points.length < 10) return;

                    // 正規化（形状のみを抽出）
                    const xCoords = points.map(p => p[0]), yCoords = points.map(p => p[1]);
                    const minX = Math.min(...xCoords), maxX = Math.max(...xCoords);
                    const minY = Math.min(...yCoords), maxY = Math.max(...yCoords);
                    const w = maxX - minX, h = maxY - minY;

                    // スライダーから質量を取得
                    const selectedMass = parseInt(massSlider.value);
                    const normalized = points.map(p => [(p[0] - minX) / w - 0.5, -((p[1] - minY) / h - 0.5)]);

                    const star = new Star({
                        points: normalized,
                        scale: selectedMass,
                        color: new THREE.Color().setHSL(Math.random(), 0.7, 0.5)
                    }, this.scene);

                    this.stars.push(star);
                    document.getElementById('stats').innerText = `STARS: ${this.stars.length}`;
                    this.startAudio();
                    overlay.classList.remove('active');
                };

                document.getElementById('sound-toggle-btn').onclick = () => {
                    this.isMuted = !this.isMuted;
                    document.getElementById('sound-toggle-btn').innerText = `SOUND: ${this.isMuted ? 'OFF' : 'ON'}`;
                    if (this.gainNode) this.gainNode.gain.setTargetAtTime(this.isMuted ? 0 : 0.2, this.audioCtx.currentTime, 0.5);
                };
            }

            startAudio() {
                if (this.audioCtx) return;
                this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                this.gainNode = this.audioCtx.createGain();
                this.gainNode.gain.setValueAtTime(0, this.audioCtx.currentTime);
                this.gainNode.connect(this.audioCtx.destination);

                const loadAmbient = async () => {
                    try {
                        const res = await fetch('assets/bgm.mp3');
                        const buf = await res.arrayBuffer();
                        const data = await this.audioCtx.decodeAudioData(buf);
                        const src = this.audioCtx.createBufferSource();
                        src.buffer = data; src.loop = true;
                        src.connect(this.gainNode);
                        src.start(0);
                        this.gainNode.gain.setTargetAtTime(this.isMuted ? 0 : 0.2, this.audioCtx.currentTime, 2.0);
                    } catch (e) {
                        // Drone fallback
                        const osc = this.audioCtx.createOscillator();
                        osc.frequency.value = 55; // Low A
                        const g = this.audioCtx.createGain();
                        g.gain.value = 0.1;
                        osc.connect(g); g.connect(this.gainNode);
                        osc.start();
                    }
                };
                loadAmbient();
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                const delta = this.clock.getDelta();
                const time = this.clock.getElapsedTime();

                // ブラックホールのリストを作成
                const blackHoles = this.stars.filter(s => s.state === 'BLACK_HOLE');

                for (let i = this.stars.length - 1; i >= 0; i--) {
                    const s = this.stars[i];

                    // 重力計算（ブラックホール以外の星に影響）
                    if (s.state !== 'BLACK_HOLE') {
                        blackHoles.forEach(bh => {
                            const dist = s.position.distanceTo(bh.position);
                            if (dist < 150) { // 影響範囲
                                // 引力ベクトル
                                const pull = new THREE.Vector3().subVectors(bh.position, s.position).normalize();
                                const force = (150 - dist) * 0.001;
                                s.velocity.add(pull.multiplyScalar(force));

                                // イベントホライズン（吸収判定）
                                if (dist < 15) {
                                    s.isExpired = true; // 吸収
                                }
                            }
                        });
                    }

                    s.update(time, delta);

                    if (s.isExpired) {
                        s.dispose();
                        this.stars.splice(i, 1);
                        document.getElementById('stats').innerText = `STARS: ${this.stars.length}`;
                    }
                }

                this.controls.update();
                this.composer.render();
            }
        }

        class Star {
            constructor(data, scene) {
                this.scene = scene;
                this.age = 0;
                this.lifespan = 20.0 + Math.random() * 40.0;
                this.state = 'BIRTH';
                this.isExpired = false;

                // 質量（サイズ）に基づいて進化タイプを決定
                this.initialScale = Math.min(Math.max(data.scale, 5), 45); // クランプ範囲を拡張
                this.currentScale = this.initialScale;
                this.baseColor = data.color;

                if (this.initialScale < 12) {
                    this.evolutionType = 'SMALL'; // -> 白色矮星
                } else if (this.initialScale < 22) {
                    this.evolutionType = 'STANDARD'; // -> 赤色巨星 -> 白色矮星
                } else if (this.initialScale < 32) {
                    this.evolutionType = 'LARGE'; // -> 超新星 -> 中性子星
                } else {
                    this.evolutionType = 'MASSIVE'; // -> 超新星 -> ブラックホール
                }

                this.position = new THREE.Vector3((Math.random() - 0.5) * 400, (Math.random() - 0.5) * 400, (Math.random() - 0.5) * 400);
                this.velocity = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).multiplyScalar(0.1);

                this.initMesh(data);
            }

            initMesh(data) {
                const pts = data.points.map(p => new THREE.Vector3(p[0] * this.initialScale * 2, p[1] * this.initialScale * 2, 0));
                const shape = new THREE.Shape();
                shape.moveTo(pts[0].x, pts[0].y);
                pts.forEach(p => shape.lineTo(p.x, p.y));

                const geo = new THREE.ExtrudeGeometry(shape, {
                    depth: 4, bevelEnabled: true, bevelSize: 4, bevelThickness: 4, bevelSegments: 3
                });

                this.material = new THREE.MeshPhongMaterial({
                    color: this.baseColor,
                    emissive: this.baseColor,
                    emissiveIntensity: 1.2,
                    specular: new THREE.Color(0xffffff),
                    shininess: 100,
                    transparent: true,
                    opacity: 0
                });

                this.mesh = new THREE.Mesh(geo, this.material);
                this.scene.add(this.mesh);

                // オーラエフェクト
                const canvas = document.createElement('canvas');
                canvas.width = 128; canvas.height = 128;
                this.auraCtx = canvas.getContext('2d');
                this.updateAuraTexture();

                this.auraTexture = new THREE.CanvasTexture(canvas);
                this.aura = new THREE.Sprite(new THREE.SpriteMaterial({ map: this.auraTexture, transparent: true, opacity: 1, blending: THREE.AdditiveBlending }));
                this.aura.scale.set(this.initialScale * 8, this.initialScale * 8, 1);
                this.mesh.add(this.aura);
            }

            updateAuraTexture(color = this.baseColor, forceWhiteCenter = false) {
                const c = this.auraCtx;
                c.clearRect(0, 0, 128, 128);
                const grad = c.createRadialGradient(64, 64, 0, 64, 64, 64);
                const colorStr = color.getStyle ? color.getStyle() : `hsl(${color.h * 360}, ${color.s * 100}%, ${color.l * 100}%)`;

                if (forceWhiteCenter) {
                    grad.addColorStop(0, 'white');
                    grad.addColorStop(0.2, 'white');
                } else {
                    grad.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                }
                grad.addColorStop(0.4, colorStr);
                grad.addColorStop(1, 'transparent');

                c.fillStyle = grad;
                c.fillRect(0, 0, 128, 128);
                if (this.auraTexture) this.auraTexture.needsUpdate = true;
            }

            update(time, delta) {
                this.age += delta;
                const progress = this.age / this.lifespan;

                if (this.state === 'BIRTH') {
                    this.material.opacity += 0.02;
                    if (this.material.opacity >= 0.9) this.state = 'EVOLUTION';
                }

                if (this.state === 'EVOLUTION') {
                    this.mesh.rotation.y += 0.01;
                    this.mesh.rotation.x += 0.005;

                    switch (this.evolutionType) {
                        case 'SMALL':
                            // 安定した小型星
                            this.currentScale = this.initialScale;
                            if (progress > 0.8) {
                                // ゆるやかに収縮させつつ、輝き（エミッシブ）を維持
                                this.currentScale *= (1.0 - (progress - 0.8) * 0.5);
                                this.material.color.lerp(new THREE.Color(0xccddff), 0.05);
                                this.material.emissiveIntensity = 1.2 + (progress - 0.8) * 2;
                            }
                            break;

                        case 'STANDARD':
                            // 赤色巨星化
                            if (progress > 0.6) {
                                this.state = 'RED_GIANT';
                            }
                            break;

                        case 'LARGE':
                        case 'MASSIVE':
                            // 巨大星・超巨大星 -> 終盤に不安定化
                            this.mesh.scale.setScalar(1.0 + Math.sin(time * 10) * progress * 0.2);
                            if (progress > 0.9) this.state = 'SUPERNOVA';
                            break;
                    }

                    // 基本的な色変化（青->黄->赤）
                    if (this.state === 'EVOLUTION') {
                        const h = (0.6 - progress * 0.4 + 1.0) % 1.0;
                        this.material.color.setHSL(h, 0.8, 0.5);
                        this.material.emissive.setHSL(h, 0.8, 0.5);
                    }
                }

                if (this.state === 'RED_GIANT') {
                    this.currentScale = this.initialScale * (1.0 + (progress - 0.6) * 4);
                    this.material.color.lerp(new THREE.Color(0xff3300), 0.05);
                    this.material.emissive.lerp(new THREE.Color(0xff3300), 0.05);
                    this.mesh.scale.setScalar(1.0 + Math.sin(time * 3) * 0.1); // 脈動
                    if (progress > 0.95) this.state = 'NEBULA_RELEASE';
                }

                if (this.state === 'SUPERNOVA') {
                    this.currentScale *= 1.05;
                    this.material.emissiveIntensity += 0.5;
                    if (this.material.emissiveIntensity > 15) {
                        if (this.evolutionType === 'LARGE') this.state = 'NEUTRON_STAR';
                        else this.state = 'BLACK_HOLE';
                        this.material.emissiveIntensity = 1.0;
                    }
                }

                if (this.state === 'NEBULA_RELEASE') {
                    this.aura.material.opacity -= 0.01;
                    this.currentScale *= 0.98;
                    if (this.currentScale < 3) {
                        this.state = 'WHITE_DWARF';
                        this.currentScale = 5;
                        this.material.opacity = 1;
                        this.updateAuraTexture(new THREE.Color(0xffffff), true);
                        this.aura.material.opacity = 1;
                    }
                }

                if (this.state === 'WHITE_DWARF') {
                    this.material.color.set(0xffffff);
                    this.material.emissive.set(0xffffff);
                    this.mesh.scale.setScalar(1.0 + Math.sin(time * 5) * 0.02);
                }

                if (this.state === 'NEUTRON_STAR') {
                    this.currentScale = 4;
                    this.material.color.set(0x00ffff);
                    this.material.emissive.set(0x00ffff);
                    this.updateAuraTexture(new THREE.Color(0x00ffff), true);
                    this.mesh.rotation.y += 0.5; // 超高速回転
                    this.aura.scale.setScalar(this.currentScale * 15 * (1.0 + Math.sin(time * 20) * 0.3));
                }

                if (this.state === 'BLACK_HOLE') {
                    this.currentScale = 8;
                    this.material.color.set(0x000000);
                    this.material.emissive.set(0x000000);
                    this.material.transparent = true;
                    this.updateAuraTexture(new THREE.Color(0x330066), false);
                    this.aura.material.blending = THREE.SubtractiveBlending; // 周囲を「吸い込む」演出
                    this.aura.scale.setScalar(this.currentScale * 10);
                }

                // --- 共通の消滅ロジック（フェードアウト） ---
                if (progress > 0.9) {
                    const fadeProgress = (progress - 0.9) * 10; // 0.0 to 1.0
                    this.material.opacity = Math.max(0, 0.9 * (1.0 - fadeProgress));
                    this.aura.material.opacity = Math.max(0, 1.0 - fadeProgress);

                    if (this.material.opacity <= 0.01 && this.aura.material.opacity <= 0.01) {
                        this.isExpired = true;
                    }
                }

                // バックアップ：寿命が完全に来たら消滅
                if (progress > 0.995) {
                    this.isExpired = true;
                }

                // スケール適用ロジック
                let pulsate = 1.0;
                if (this.state === 'EVOLUTION') {
                    if (this.evolutionType === 'LARGE' || this.evolutionType === 'MASSIVE') {
                        pulsate = 1.0 + Math.sin(time * 10) * progress * 0.2;
                    } else {
                        pulsate = 1.0 + Math.sin(time * 2) * 0.05;
                    }
                } else if (this.state === 'RED_GIANT') {
                    pulsate = 1.0 + Math.sin(time * 3) * 0.1;
                } else if (this.state === 'WHITE_DWARF') {
                    pulsate = 1.0 + Math.sin(time * 5) * 0.02;
                } else if (this.state === 'NEUTRON_STAR') {
                    pulsate = 1.0 + Math.sin(time * 20) * 0.3;
                }

                const s = this.currentScale / this.initialScale;
                this.mesh.scale.setScalar(s * pulsate);

                // オーラのスケーリング（ブラックホール以外はAdditive）
                if (this.state !== 'BLACK_HOLE') {
                    this.aura.scale.setScalar(this.currentScale * 8 * pulsate);
                } else {
                    this.aura.scale.setScalar(this.currentScale * 10);
                }

                this.position.add(this.velocity);
                this.mesh.position.copy(this.position);
            }

            dispose() {
                this.scene.remove(this.mesh);
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
                this.aura.material.dispose();
                this.auraTexture.dispose();
            }
        }

        new Simulation();
    </script>
</body>

</html>