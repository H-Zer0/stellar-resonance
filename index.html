<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DEEP SEA SYMBIOSIS | Next-Gen Abyss</title>
    <style>
        :root {
            --bg: #000510;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body,
        html {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: var(--bg);
            color: white;
            font-family: "Optima", serif;
            cursor: crosshair;
        }

        #canvas-wrapper {
            position: absolute;
            inset: 0;
            z-index: 1;
        }

        #overlay {
            position: absolute;
            inset: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            z-index: 10;
        }

        #intro-text {
            font-size: 1.2rem;
            letter-spacing: 0.8rem;
            opacity: 0;
            transition: opacity 3s, transform 3s;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        #intro-text.visible {
            opacity: 0.7;
            transform: translateY(0);
        }

        .breathing {
            animation: breathe 6s ease-in-out infinite;
        }

        @keyframes breathe {

            0%,
            100% {
                opacity: 0.2;
            }

            50% {
                opacity: 0.8;
            }
        }
    </style>
</head>

<body>
    <div id="canvas-wrapper"></div>
    <div id="overlay">
        <div id="intro-text" class="breathing">闇をなぞる、生命が灯る</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        (function () {
            if (typeof THREE === 'undefined') return;

            // --- CONSTANTS ---
            const GRID_SIZE = 64;
            const CREATURE_LIMIT = 100;
            const SNOW_COUNT = 3000;
            const COLORS = [0x00FFFF, 0xFF00FF, 0x007FFF, 0x7FFF00, 0xFFFF00];

            // --- UTILS ---
            const lerp = (a, b, t) => a + (b - a) * t;

            // --- FLUID FIELD (CPU Grid) ---
            class FluidField {
                constructor(size) {
                    this.size = size;
                    this.grid = new Float32Array(size * size * 2); // vx, vy
                    this.density = new Float32Array(size * size);
                }

                addVelocity(x, y, vx, vy, radius = 2) {
                    const gx = Math.floor(((x + 10) / 20) * this.size);
                    const gy = Math.floor(((y + 10) / 20) * this.size);

                    for (let i = -radius; i <= radius; i++) {
                        for (let j = -radius; j <= radius; j++) {
                            const nx = gx + i;
                            const ny = gy + j;
                            if (nx >= 0 && nx < this.size && ny >= 0 && ny < this.size) {
                                const idx = (ny * this.size + nx) * 2;
                                const weight = 1 / (1 + Math.sqrt(i * i + j * j));
                                this.grid[idx] += vx * weight * 0.5;
                                this.grid[idx + 1] += vy * weight * 0.5;
                            }
                        }
                    }
                }

                update(time) {
                    for (let i = 0; i < this.grid.length; i++) {
                        this.grid[i] *= 0.97; // Slightly higher dampening
                    }
                    // Add ambient turbulence (Sea Current)
                    const t = time * 0.3;
                    for (let i = 0; i < 5; i++) {
                        const rx = Math.floor(Math.random() * this.size);
                        const ry = Math.floor(Math.random() * this.size);
                        const idx = (ry * this.size + rx) * 2;
                        this.grid[idx] += Math.sin(t + i) * 0.05;
                        this.grid[idx + 1] += Math.cos(t + i) * 0.05;
                    }
                }

                getVelocity(x, y) {
                    const gx = Math.floor(((x + 15) / 30) * this.size);
                    const gy = Math.floor(((y + 15) / 30) * this.size);
                    if (gx < 0 || gx >= this.size || gy < 0 || gy >= this.size) return { x: 0, y: 0 };
                    const idx = (gy * this.size + gx) * 2;
                    return { x: this.grid[idx], y: this.grid[idx + 1] };
                }
            }

            // --- RIBBON ENTITY ---
            class Creature {
                constructor(initialPoints, color, scene) {
                    this.scene = scene;
                    this.points = [];
                    this.segments = initialPoints.length;
                    this.color = new THREE.Color(color);
                    this.energy = 1.0;
                    this.decay = 0.0008 + Math.random() * 0.0012;

                    // Initial skeleton from user drawing
                    for (let i = 0; i < this.segments; i++) {
                        this.points.push(initialPoints[i].clone());
                    }

                    this.pos = initialPoints[0].clone();
                    this.vel = new THREE.Vector2(0, 0);
                    this.angle = Math.random() * Math.PI * 2;
                    this.speed = 0.02 + Math.random() * 0.04;
                    this.noiseSeed = Math.random() * 100;

                    // Create Ribbon Mesh
                    this.geometry = new THREE.BufferGeometry();
                    const vertices = new Float32Array(this.segments * 2 * 3);
                    this.geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));

                    this.material = new THREE.ShaderMaterial({
                        uniforms: {
                            uColor: { value: this.color },
                            uEnergy: { value: this.energy },
                            uTime: { value: 0 }
                        },
                        vertexShader: `
                            varying vec2 vUv;
                            void main() {
                                vUv = uv;
                                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            }
                        `,
                        fragmentShader: `
                            uniform vec3 uColor;
                            uniform float uEnergy;
                            uniform float uTime;
                            varying vec2 vUv;
                            void main() {
                                float glow1 = pow(1.0 - abs(vUv.y - 0.5) * 2.0, 5.0);
                                float glow2 = pow(1.0 - abs(vUv.y - 0.5) * 2.0, 1.2) * 0.4;
                                float pulse = 0.8 + 0.2 * sin(uTime * 4.0 + vUv.x * 5.0);
                                vec3 finalColor = mix(uColor, vec3(1.0), glow1 * 0.7);
                                float alpha = (glow1 + glow2) * uEnergy * pulse * (1.0 - vUv.x);
                                gl_FragColor = vec4(finalColor, alpha);
                            }
                        `,
                        transparent: true,
                        blending: THREE.AdditiveBlending,
                        side: THREE.DoubleSide,
                        depthWrite: false
                    });

                    this.mesh = new THREE.Mesh(this.geometry, this.material);
                    this.scene.add(this.mesh);
                }

                update(time, fluid) {
                    // Lead movement
                    const fVel = fluid.getVelocity(this.pos.x, this.pos.y);
                    this.vel.x += fVel.x * 0.12;
                    this.vel.y += fVel.y * 0.12;

                    const noise = Math.sin(time * 0.8 + this.noiseSeed) * 0.02;
                    this.angle += noise;

                    const moveX = Math.cos(this.angle) * this.speed;
                    const moveY = Math.sin(this.angle) * this.speed;
                    this.pos.x += moveX + this.vel.x;
                    this.pos.y += moveY + this.vel.y;

                    this.vel.multiplyScalar(0.97);

                    // Re-orient the whole creature towards movement
                    const head = this.points[0];
                    const dx = this.pos.x - head.x;
                    const dy = this.pos.y - head.y;
                    head.x = this.pos.x;
                    head.y = this.pos.y;

                    fluid.addVelocity(this.pos.x, this.pos.y, dx * 3, dy * 3, 2);

                    // Social behavior (simple wiggle along body)
                    for (let i = 1; i < this.segments; i++) {
                        const p = this.points[i];
                        const prev = this.points[i - 1];

                        const targetX = prev.x;
                        const targetY = prev.y;

                        // Wiggle effect
                        const wiggle = Math.sin(time * 3 + i * 0.2) * 0.02;
                        p.x = lerp(p.x, targetX, 0.15) + wiggle;
                        p.y = lerp(p.y, targetY, 0.15);
                    }

                    // Update Topology mesh
                    const attr = this.geometry.attributes.position;
                    const baseThickness = 0.2;

                    for (let i = 0; i < this.segments; i++) {
                        const p = this.points[i];
                        const prev = i > 0 ? this.points[i - 1] : (i < this.segments - 1 ? this.points[i + 1] : p);
                        const angle = Math.atan2(p.y - prev.y, p.x - prev.x);
                        const nx = Math.sin(angle);
                        const ny = -Math.cos(angle);

                        const taper = Math.pow(1.0 - i / this.segments, 0.7);
                        const currentThickness = baseThickness * taper;

                        attr.setXYZ(i * 2, p.x + nx * currentThickness, p.y + ny * currentThickness, 1.0);
                        attr.setXYZ(i * 2 + 1, p.x - nx * currentThickness, p.y - ny * currentThickness, 1.0);
                    }
                    attr.needsUpdate = true;

                    this.energy -= this.decay;
                    this.material.uniforms.uEnergy.value = this.energy;
                    this.material.uniforms.uTime.value = time;
                }

                isDead() { return this.energy <= 0; }
                destroy() {
                    this.scene.remove(this.mesh);
                    this.geometry.dispose();
                    this.material.dispose();
                }
            }

            // --- MAIN ENGINE ---
            class AbyssEngine {
                constructor() {
                    this.container = document.getElementById('canvas-wrapper');
                    this.introText = document.getElementById('intro-text');
                    this.creatures = [];
                    this.fluid = new FluidField(GRID_SIZE);
                    this.mouse = new THREE.Vector2();
                    this.prevMouse = new THREE.Vector2();
                    this.isDown = false;
                    this.isDrawing = false;
                    this.currentStroke = [];
                    this.time = 0;
                    this.phase = 0;

                    this.init();
                    this.animate();

                    window.addEventListener('load', () => {
                        this.introText.classList.add('visible');
                        this.phase = 1;
                    });
                }

                init() {
                    this.scene = new THREE.Scene();
                    this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                    this.camera.position.z = 15;

                    this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                    this.renderer.autoClear = false;
                    this.renderer.setClearColor(0x000510, 1);
                    this.container.appendChild(this.renderer.domElement);

                    // Feedback trails
                    this.fadePlane = new THREE.Mesh(
                        new THREE.PlaneGeometry(100, 100),
                        new THREE.MeshBasicMaterial({ color: 0x000510, transparent: true, opacity: 0.1 })
                    );
                    this.fadePlane.position.z = 1;
                    this.scene.add(this.fadePlane);

                    // Space Particles (Marine Snow)
                    const snowGeo = new THREE.BufferGeometry();
                    const snowPos = new Float32Array(SNOW_COUNT * 3);
                    for (let i = 0; i < SNOW_COUNT * 3; i++) snowPos[i] = THREE.MathUtils.randFloatSpread(50);
                    snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPos, 3));
                    this.snow = new THREE.Points(snowGeo, new THREE.PointsMaterial({ color: 0x00FFFF, size: 0.03, transparent: true, opacity: 0.2 }));
                    this.scene.add(this.snow);

                    // Atmosphere Rays
                    const rayGeo = new THREE.PlaneGeometry(40, 40);
                    const rayMat = new THREE.ShaderMaterial({
                        uniforms: { uTime: { value: 0 } },
                        vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
                        fragmentShader: `
                            uniform float uTime;
                            varying vec2 vUv;
                            void main() {
                                float beam = sin(vUv.x * 20.0 + uTime * 0.5) * 0.5 + 0.5;
                                float alpha = (1.0 - vUv.y) * 0.1 * beam;
                                gl_FragColor = vec4(0.0, 0.5, 1.0, alpha);
                            }
                        `,
                        transparent: true,
                        blending: THREE.AdditiveBlending,
                        side: THREE.DoubleSide
                    });
                    this.rays = new THREE.Mesh(rayGeo, rayMat);
                    this.rays.position.set(0, 10, -5);
                    this.rays.rotation.x = -Math.PI / 3;
                    this.scene.add(this.rays);

                    // Deep Sea Haze (Background Noise)
                    const hazeGeo = new THREE.PlaneGeometry(100, 100);
                    const hazeMat = new THREE.ShaderMaterial({
                        uniforms: { uTime: { value: 0 } },
                        vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
                        fragmentShader: `
                            uniform float uTime;
                            varying vec2 vUv;
                            float noise(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453); }
                            void main() {
                                float n = noise(vUv * 5.0 + uTime * 0.1);
                                float smoke = sin(vUv.x * 3.0 + uTime * 0.2) * cos(vUv.y * 3.0 + uTime * 0.3) * 0.5 + 0.5;
                                gl_FragColor = vec4(0.0, 0.05, 0.1, smoke * 0.08);
                            }
                        `,
                        transparent: true,
                        depthWrite: false,
                        blending: THREE.AdditiveBlending
                    });
                    this.haze.position.z = -15; // Far back
                    this.scene.add(this.haze);

                    // Preview Line for drawing
                    const previewGeo = new THREE.BufferGeometry();
                    const previewPos = new Float32Array(500 * 3);
                    previewGeo.setAttribute('position', new THREE.BufferAttribute(previewPos, 3));
                    this.previewLine = new THREE.Line(previewGeo, new THREE.LineBasicMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.5 }));
                    this.scene.add(this.previewLine);
                }

                bindEvents() {
                    const getPoint = (e) => {
                        const v = new THREE.Vector3((e.clientX / window.innerWidth) * 2 - 1, -(e.clientY / window.innerHeight) * 2 + 1, 0.5).unproject(this.camera);
                        const dir = v.sub(this.camera.position).normalize();
                        return this.camera.position.clone().add(dir.multiplyScalar(-this.camera.position.z / dir.z));
                    };

                    const start = (e) => {
                        this.isDown = true;
                        this.currentStroke = [];
                        if (this.phase === 1) {
                            this.phase = 2;
                            this.introText.classList.remove('visible');
                        }
                    };
                    const move = (e) => {
                        if (this.isDown) {
                            const p = getPoint(e.touches ? e.touches[0] : e);
                            this.currentStroke.push(p);
                            if (this.currentStroke.length > 500) this.currentStroke.shift();

                            // Update preview line
                            const pos = this.previewLine.geometry.attributes.position.array;
                            for (let i = 0; i < this.currentStroke.length; i++) {
                                pos[i * 3] = this.currentStroke[i].x;
                                pos[i * 3 + 1] = this.currentStroke[i].y;
                                pos[i * 3 + 2] = this.currentStroke[i].z;
                            }
                            this.previewLine.geometry.setDrawRange(0, this.currentStroke.length);
                            this.previewLine.geometry.attributes.position.needsUpdate = true;

                            // Add fluid velocity from brush
                            if (this.currentStroke.length > 1) {
                                const head = this.currentStroke[this.currentStroke.length - 1];
                                const prev = this.currentStroke[this.currentStroke.length - 2];
                                this.fluid.addVelocity(head.x, head.y, (head.x - prev.x) * 5, (head.y - prev.y) * 5, 2);
                            }
                        }
                    };
                    const end = () => {
                        if (this.isDown && this.currentStroke.length > 5) {
                            this.spawnFromStroke();
                        }
                        this.isDown = false;
                        this.currentStroke = [];
                        this.previewLine.geometry.setDrawRange(0, 0);
                    };

                    window.addEventListener('mousedown', start);
                    window.addEventListener('mousemove', move);
                    window.addEventListener('mouseup', end);
                    window.addEventListener('touchstart', (e) => { e.preventDefault(); start(e.touches[0]); }, { passive: false });
                    window.addEventListener('touchmove', (e) => { e.preventDefault(); move(e.touches[0]); }, { passive: false });
                    window.addEventListener('touchend', end);

                    window.addEventListener('resize', () => {
                        this.camera.aspect = window.innerWidth / window.innerHeight;
                        this.camera.updateProjectionMatrix();
                        this.renderer.setSize(window.innerWidth, window.innerHeight);
                    });
                }

                spawnFromStroke() {
                    if (this.creatures.length > CREATURE_LIMIT) return;

                    // Resample stroke to a manageable number of segments (e.g., 30)
                    const resampled = [];
                    const steps = 30;
                    for (let i = 0; i < steps; i++) {
                        const t = i / (steps - 1);
                        const idx = Math.floor(t * (this.currentStroke.length - 1));
                        resampled.push(this.currentStroke[idx].clone());
                    }

                    const color = COLORS[Math.floor(Math.random() * COLORS.length)];
                    this.creatures.push(new Creature(resampled, color, this.scene));

                    this.spawnBurst(resampled[0].x, resampled[0].y, 10);
                }

                spawnBurst(x, y, count) {
                    for (let i = 0; i < count; i++) {
                        const px = x + (Math.random() - 0.5);
                        const py = y + (Math.random() - 0.5);
                        const p = [];
                        for (let j = 0; j < 10; j++) p.push(new THREE.Vector3(px, py, 0));
                        // this.creatures.push(new Creature(p, COLORS[0], this.scene)); // Burst not needed or different
                    }
                }

                animate() {
                    requestAnimationFrame(() => this.animate());
                    this.time += 0.016;
                    this.fluid.update(this.time);

                    // Render Feedback
                    this.fadePlane.position.copy(this.camera.position).add(this.camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(1));
                    this.renderer.render(this.scene, this.camera);

                    // Update Entities
                    for (let i = this.creatures.length - 1; i >= 0; i--) {
                        const c = this.creatures[i];
                        c.update(this.time, this.fluid);
                        if (c.isDead()) {
                            c.destroy();
                            this.creatures.splice(i, 1);
                        }
                    }

                    // Snow Fluid Effect
                    const pos = this.snow.geometry.attributes.position.array;
                    for (let i = 0; i < SNOW_COUNT; i++) {
                        const x = pos[i * 3];
                        const y = pos[i * 3 + 1];
                        const v = this.fluid.getVelocity(x, y);
                        pos[i * 3] += v.x * 0.2;
                        pos[i * 3 + 1] += v.y * 0.2 - 0.005; // Fall + fluid
                        if (pos[i * 3 + 1] < -15) pos[i * 3 + 1] = 15;
                    }
                    this.snow.geometry.attributes.position.needsUpdate = true;

                    if (this.rays) this.rays.material.uniforms.uTime.value = this.time;
                    if (this.haze) this.haze.material.uniforms.uTime.value = this.time;

                    this.renderer.render(this.scene, this.camera);
                }
            }

            window.onload = () => new AbyssEngine();
        })();
    </script>
</body>

</html>