<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DEEP SEA SYMBIOSIS | Abyss Evolution</title>
    <style>
        :root {
            --deep-sea-bg: #000510;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            outline: none;
        }

        body,
        html {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--deep-sea-bg);
            color: white;
            font-family: "Optima", "Inter", "Noto Sans JP", sans-serif;
            cursor: crosshair;
        }

        #canvas-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            z-index: 10;
            background: radial-gradient(circle at center, transparent 0%, rgba(0, 5, 16, 0.4) 100%);
        }

        #intro-text {
            font-size: clamp(1rem, 4vw, 1.2rem);
            letter-spacing: 0.8rem;
            color: rgba(255, 255, 255, 0.9);
            opacity: 0;
            transition: opacity 3s ease, transform 3s ease;
            text-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
            z-index: 11;
            font-weight: 200;
            transform: translateY(10px);
        }

        #intro-text.visible {
            opacity: 0.8;
            transform: translateY(0);
        }

        .breathing {
            animation: breathe 6s ease-in-out infinite;
        }

        @keyframes breathe {

            0%,
            100% {
                opacity: 0.2;
                transform: scale(0.98);
                filter: blur(1px);
            }

            50% {
                opacity: 0.9;
                transform: scale(1.02);
                filter: blur(0px);
            }
        }
    </style>
</head>

<body>
    <div id="container">
        <div id="canvas-wrapper"></div>
        <div id="overlay">
            <div id="intro-text" class="breathing">闇をなぞる、生命が灯る</div>
        </div>
    </div>

    <!-- WebGL Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        (function () {
            if (typeof THREE === 'undefined') {
                document.body.innerHTML = '<div style="display:flex;justify-content:center;align-items:center;height:100vh;">Internet Connection Required for Three.js</div>';
                return;
            }

            // --- CONFIGURATION ---
            const CONFIG = {
                creatureCount: 300,
                segments: 20,
                segmentDist: 0.15,
                colors: [0x00FFFF, 0xFF00FF, 0x007FFF, 0x7FFF00],
                bloom: { strength: 2.5, radius: 0.5, threshold: 0.1 }
            };

            // --- UTILS ---
            const lerp = (a, b, t) => a + (b - a) * t;

            // --- CREATURE CLASS (ORGANIC MOTION) ---
            class Creature {
                constructor(x, y, color, scene) {
                    this.scene = scene;
                    this.points = [];
                    this.segments = CONFIG.segments;
                    this.color = new THREE.Color(color);
                    this.energy = 1.0 + Math.random() * 0.5;
                    this.decay = 0.001 + Math.random() * 0.002;
                    this.speed = 0.05 + Math.random() * 0.1;
                    this.noiseOffset = Math.random() * 1000;

                    // Trail geometry (Ribbon-like)
                    for (let i = 0; i < this.segments; i++) {
                        this.points.push(new THREE.Vector3(x, y, 0));
                    }

                    this.geometry = new THREE.BufferGeometry().setFromPoints(this.points);

                    // Create glow material
                    this.material = new THREE.LineBasicMaterial({
                        color: this.color,
                        transparent: true,
                        opacity: 0.8,
                        blending: THREE.AdditiveBlending,
                        linewidth: 2
                    });

                    this.line = new THREE.Line(this.geometry, this.material);
                    this.scene.add(this.line);

                    // Add head particle for "glow" intensity
                    const dotGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0)]);
                    const dotMat = new THREE.PointsMaterial({
                        color: this.color,
                        size: 0.4,
                        transparent: true,
                        blending: THREE.AdditiveBlending,
                        opacity: 1.0
                    });
                    this.head = new THREE.Points(dotGeo, dotMat);
                    this.scene.add(this.head);
                }

                update(time, flowField) {
                    // Motion Logic
                    const head = this.points[0];
                    const angle = flowField.getAt(head.x, head.y, time + this.noiseOffset);

                    head.x += Math.cos(angle) * this.speed;
                    head.y += Math.sin(angle) * this.speed;
                    this.head.position.copy(head);

                    // Smooth segment follow (Inverse Kinematics style)
                    for (let i = 1; i < this.segments; i++) {
                        const p = this.points[i];
                        const prev = this.points[i - 1];
                        const dx = p.x - prev.x;
                        const dy = p.y - prev.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const angle = Math.atan2(dy, dx);

                        p.x = prev.x + Math.cos(angle) * CONFIG.segmentDist;
                        p.y = prev.y + Math.sin(angle) * CONFIG.segmentDist;
                    }

                    // Metabolism
                    this.energy -= this.decay;
                    this.material.opacity = Math.max(0, this.energy * 0.7);
                    this.head.material.opacity = Math.max(0, this.energy);

                    this.geometry.setFromPoints(this.points);
                    this.geometry.attributes.position.needsUpdate = true;
                }

                isDead() { return this.energy <= 0; }
                destroy() {
                    this.scene.remove(this.line);
                    this.scene.remove(this.head);
                    this.geometry.dispose();
                    this.material.dispose();
                }
            }

            // --- WORLD ENGINE ---
            class AbyssEngine {
                constructor() {
                    this.container = document.getElementById('canvas-wrapper');
                    this.introText = document.getElementById('intro-text');
                    this.creatures = [];
                    this.phase = 1;
                    this.mouse = new THREE.Vector2();
                    this.isDown = false;
                    this.time = 0;

                    this.init();
                    this.loop();

                    // Show intro
                    setTimeout(() => this.introText.classList.add('visible'), 500);
                }

                init() {
                    this.scene = new THREE.Scene();
                    this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                    this.camera.position.z = 15;

                    this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                    this.renderer.setClearColor(0x000510, 1);
                    this.container.appendChild(this.renderer.domElement);

                    // Marine Snow
                    const snowCount = 4000;
                    const snowGeo = new THREE.BufferGeometry();
                    const snowPos = [];
                    for (let i = 0; i < snowCount; i++) {
                        snowPos.push(THREE.MathUtils.randFloatSpread(50), THREE.MathUtils.randFloatSpread(40), THREE.MathUtils.randFloatSpread(40));
                    }
                    snowGeo.setAttribute('position', new THREE.Float32BufferAttribute(snowPos, 3));
                    this.snow = new THREE.Points(snowGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.05, transparent: true, opacity: 0.2, blending: THREE.AdditiveBlending }));
                    this.scene.add(snow);

                    this.bindEvents();
                }

                bindEvents() {
                    window.addEventListener('resize', () => {
                        this.camera.aspect = window.innerWidth / window.innerHeight;
                        this.camera.updateProjectionMatrix();
                        this.renderer.setSize(window.innerWidth, window.innerHeight);
                    });

                    const handleDown = (e) => {
                        this.isDown = true;
                        this.updateMouse(e);
                        if (this.phase === 1) {
                            this.phase = 2;
                            this.introText.classList.remove('visible');
                            setTimeout(() => this.introText.style.display = 'none', 3000);
                        }
                        this.spawn(3);
                    };
                    const handleMove = (e) => {
                        this.updateMouse(e);
                        if (this.isDown) this.spawn(1);
                    };
                    const handleUp = () => this.isDown = false;

                    window.addEventListener('mousedown', handleDown);
                    window.addEventListener('mousemove', handleMove);
                    window.addEventListener('mouseup', handleUp);
                    window.addEventListener('touchstart', (e) => handleDown(e.touches[0]));
                    window.addEventListener('touchmove', (e) => handleMove(e.touches[0]));
                    window.addEventListener('touchend', handleUp);
                }

                updateMouse(e) {
                    this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                    this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                }

                spawn(count) {
                    if (this.creatures.length > 500) return;

                    const vector = new THREE.Vector3(this.mouse.x, this.mouse.y, 0.5);
                    vector.unproject(this.camera);
                    const dir = vector.sub(this.camera.position).normalize();
                    const pos = this.camera.position.clone().add(dir.multiplyScalar(-this.camera.position.z / dir.z));

                    for (let i = 0; i < count; i++) {
                        const color = CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)];
                        this.creatures.push(new Creature(pos.x, pos.y, color, this.scene));
                    }
                }

                loop() {
                    requestAnimationFrame(() => this.loop());
                    this.time += 0.01;

                    // Update Creatures
                    for (let i = this.creatures.length - 1; i >= 0; i--) {
                        const c = this.creatures[i];
                        c.update(this.time, this.flowField());
                        if (c.isDead()) {
                            c.destroy();
                            this.creatures.splice(i, 1);
                        }
                    }

                    // Animate Marine Snow
                    this.snow.position.y -= 0.005;
                    this.snow.rotation.y += 0.0002;
                    if (this.snow.position.y < -10) this.snow.position.y = 10;

                    this.renderer.render(this.scene, this.camera);
                }

                flowField() {
                    return {
                        getAt: (x, y, t) => {
                            // Organic flow field using sin/cos combinations (replaces Noise)
                            return Math.sin(x * 0.2 + t) * Math.cos(y * 0.2 + t) * Math.PI * 4;
                        }
                    };
                }
            }

            // Start
            window.onload = () => new AbyssEngine();
        })();
    </script>
</body>

</html>