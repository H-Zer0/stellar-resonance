<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STELLAR CYCLE | Resonance</title>
    <style>
        :root {
            --accent: #f0faff;
            --bg: #000205;
            --glass: rgba(10, 20, 40, 0.6);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            overflow: hidden;
        }

        body {
            background: var(--bg);
            font-family: 'Outfit', sans-serif;
            color: white;
            -webkit-user-select: none;
            user-select: none;
        }

        #ui-overlay {
            position: absolute;
            inset: 0;
            z-index: 100;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 2.5rem;
        }

        .glass-panel {
            pointer-events: auto;
            background: var(--glass);
            backdrop-filter: blur(25px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 1.5rem 2rem;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
        }

        h1 {
            font-size: 1.4rem;
            letter-spacing: 0.5em;
            color: var(--accent);
            text-transform: uppercase;
            font-weight: 300;
        }

        #bottom-bar {
            display: flex;
            align-items: center;
            gap: 1.5rem;
            justify-content: center;
        }

        .btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 1.2rem 3rem;
            border-radius: 50px;
            cursor: pointer;
            transition: 0.5s cubic-bezier(0.19, 1, 0.22, 1);
            text-transform: uppercase;
            letter-spacing: 0.2em;
            font-size: 0.9rem;
            pointer-events: auto;
        }

        .btn:hover {
            background: white;
            color: black;
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.4);
            transform: translateY(-2px);
        }

        #sketch-overlay {
            position: absolute;
            inset: 0;
            z-index: 200;
            background: rgba(0, 0, 0, 0.92);
            display: none;
            cursor: crosshair;
        }

        #sketch-overlay.active {
            display: block;
        }

        #sketch-canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
        }

        #sketch-ui {
            position: absolute;
            bottom: 8%;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 2rem;
            z-index: 210;
        }

        #sketch-hint {
            position: absolute;
            top: 12%;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 1.6rem;
            pointer-events: none;
            letter-spacing: 0.4rem;
            z-index: 210;
            font-weight: 200;
        }
    </style>
</head>

<body>

    <div id="ui-overlay">
        <div id="top-bar" class="glass-panel">
            <h1>Stellar Cycle</h1>
            <div id="stats"
                style="font-family: 'Courier New', monospace; letter-spacing: 0.1em; color: rgba(255,255,255,0.6);">
                STARS: 0</div>
        </div>
        <div id="bottom-bar">
            <button class="btn" id="open-sketch-btn">星を創造する</button>
            <button class="btn" id="sound-toggle-btn">SOUND: OFF</button>
        </div>
    </div>

    <div id="sketch-overlay">
        <div id="sketch-hint">深宇宙に描く輝きのカタチ</div>
        <div id="sketch-ui">
            <button class="btn" id="confirm-sketch-btn">宇宙へ放つ</button>
            <button class="btn" id="clear-sketch-btn">無に帰す</button>
            <button class="btn" id="close-sketch-btn">閉じる</button>
        </div>
        <canvas id="sketch-canvas"></canvas>
    </div>

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <script>
        /**
         * STELLAR CYCLE | Resonance
         * A cosmic simulation of star birth and supernova.
         */

        class Simulation {
            constructor() {
                this.stars = [];
                this.isMuted = true;
                this.audioCtx = null;
                this.gainNode = null;
                this.bgmPlaying = false;

                this.initThree();
                this.initSketchLayer();
                this.animate();
            }

            initThree() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x000205, 0.001);

                this.camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 1, 5000);
                this.camera.position.set(0, 100, 400);

                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.setClearColor(0x000205);
                document.body.appendChild(this.renderer.domElement);

                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.autoRotate = true;
                this.controls.autoRotateSpeed = 0.2;

                // Lighting: Space Optimization
                this.scene.add(new THREE.AmbientLight(0x111122, 0.5));
                const centerLight = new THREE.PointLight(0xffffff, 0.5, 1000);
                this.scene.add(centerLight);

                // Post-processing
                const renderPass = new THREE.RenderPass(this.scene, this.camera);
                const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 2.5, 0.4, 0.85);
                bloomPass.threshold = 0.1;
                bloomPass.strength = 2.0;
                bloomPass.radius = 0.8;

                this.composer = new THREE.EffectComposer(this.renderer);
                this.composer.addPass(renderPass);
                this.composer.addPass(bloomPass);

                this.addBackgroundStars();
            }

            addBackgroundStars() {
                const geo = new THREE.BufferGeometry();
                const pos = new Float32Array(15000 * 3);
                const col = new Float32Array(15000 * 3);
                for (let i = 0; i < 15000; i++) {
                    pos[i * 3] = (Math.random() - 0.5) * 4000;
                    pos[i * 3 + 1] = (Math.random() - 0.5) * 4000;
                    pos[i * 3 + 2] = (Math.random() - 0.5) * 4000;
                    const lum = 0.5 + Math.random() * 0.5;
                    col[i * 3] = lum; col[i * 3 + 1] = lum; col[i * 3 + 2] = lum;
                }
                geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                geo.setAttribute('color', new THREE.BufferAttribute(col, 3));
                const mat = new THREE.PointsMaterial({ size: 1.5, vertexColors: true, transparent: true, opacity: 0.8 });
                this.bgStars = new THREE.Points(geo, mat);
                this.scene.add(this.bgStars);
            }

            initSketchLayer() {
                const overlay = document.getElementById('sketch-overlay');
                const canvas = document.getElementById('sketch-canvas');
                const ctx = canvas.getContext('2d');
                let points = [];
                let isDrawing = false;

                const resize = () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; };
                window.addEventListener('resize', resize);
                resize();

                document.getElementById('open-sketch-btn').onclick = () => {
                    overlay.classList.add('active');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    points = [];
                };

                document.getElementById('close-sketch-btn').onclick = () => overlay.classList.remove('active');
                document.getElementById('clear-sketch-btn').onclick = () => { ctx.clearRect(0, 0, canvas.width, canvas.height); points = []; };

                const getXY = (e) => {
                    const t = e.touches ? e.touches[0] : e;
                    return [t.clientX, t.clientY];
                };

                canvas.onpointerdown = (e) => { isDrawing = true; points.push(getXY(e)); };
                canvas.onpointermove = (e) => {
                    if (!isDrawing) return;
                    const p = getXY(e);
                    ctx.beginPath();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = 'rgba(255,255,255,0.8)';
                    const last = points[points.length - 1];
                    ctx.moveTo(last[0], last[1]);
                    ctx.lineTo(p[0], p[1]);
                    ctx.stroke();
                    points.push(p);
                };
                canvas.onpointerup = () => { isDrawing = false; };

                document.getElementById('confirm-sketch-btn').onclick = () => {
                    if (points.length < 5) return;

                    // Analyze Sketch for Star Params
                    const xCoords = points.map(p => p[0]);
                    const yCoords = points.map(p => p[1]);
                    const minX = Math.min(...xCoords), maxX = Math.max(...xCoords);
                    const minY = Math.min(...yCoords), maxY = Math.max(...yCoords);
                    const w = maxX - minX, h = maxY - minY;
                    const size = Math.max(w, h);

                    // Normalized Shape
                    const normalized = points.map(p => [(p[0] - minX) / w - 0.5, (p[1] - minY) / h - 0.5]);

                    this.createStar(normalized, size);
                    this.startBgm();
                    overlay.classList.remove('active');
                };

                document.getElementById('sound-toggle-btn').onclick = () => {
                    this.isMuted = !this.isMuted;
                    document.getElementById('sound-toggle-btn').innerText = `SOUND: ${this.isMuted ? 'OFF' : 'ON'}`;
                    if (this.gainNode) this.gainNode.gain.setTargetAtTime(this.isMuted ? 0 : 0.2, this.audioCtx.currentTime, 0.5);
                };
            }

            createStar(shape, pixelSize) {
                const star = new Star(shape, pixelSize, this.scene);
                this.stars.push(star);
                document.getElementById('stats').innerText = `STARS: ${this.stars.length}`;
            }

            startBgm() {
                if (this.bgmPlaying) return;
                this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                this.gainNode = this.audioCtx.createGain();
                this.gainNode.gain.setValueAtTime(0, this.audioCtx.currentTime);
                this.gainNode.connect(this.audioCtx.destination);

                const load = async () => {
                    try {
                        const res = await fetch('assets/bgm.mp3');
                        const buf = await res.arrayBuffer();
                        const data = await this.audioCtx.decodeAudioData(buf);
                        const src = this.audioCtx.createBufferSource();
                        src.buffer = data; src.loop = true;
                        src.connect(this.gainNode);
                        src.start(0);
                        this.gainNode.gain.setTargetAtTime(this.isMuted ? 0 : 0.2, this.audioCtx.currentTime, 2.0);
                    } catch (e) { console.warn("Space BGM load failed."); }
                };
                load();
                this.bgmPlaying = true;
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                const delta = this.clock.getDelta();
                const time = this.clock.getElapsedTime();

                for (let i = this.stars.length - 1; i >= 0; i--) {
                    const s = this.stars[i];
                    s.update(delta, time);
                    if (s.isGone) {
                        s.dispose();
                        this.stars.splice(i, 1);
                        document.getElementById('stats').innerText = `STARS: ${this.stars.length}`;
                    }
                }

                if (this.bgStars) this.bgStars.rotation.y += 0.0001;
                this.controls.update();
                this.composer.render();
            }
        }

        class Star {
            constructor(shape, pixelSize, scene) {
                this.scene = scene;
                this.isExploding = false;
                this.isGone = false;
                this.age = 0;
                this.lifespan = 20 + Math.random() * 40; // Seconds of life

                // Initial Scaling from Sketch
                this.baseSize = Math.max(5, pixelSize * 0.15);
                this.position = new THREE.Vector3((Math.random() - 0.5) * 800, (Math.random() - 0.5) * 800, (Math.random() - 0.5) * 800);

                this.initMesh(shape);
            }

            initMesh(shape) {
                // Create Mesh from Sketch Path
                const points = shape.map(p => new THREE.Vector3(p[0] * this.baseSize, p[1] * this.baseSize, 0));

                // Use a glowing sphere as core, and the sketch as a "Stellar Halo"
                const coreGeo = new THREE.IcosahedronGeometry(this.baseSize * 0.4, 4);
                this.material = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    emissive: 0xffffff,
                    emissiveIntensity: 1.5
                });
                this.core = new THREE.Mesh(coreGeo, this.material);

                // Halo from Sketch
                const haloCurve = new THREE.CatmullRomCurve3(points);
                const haloGeo = new THREE.TubeGeometry(haloCurve, 32, this.baseSize * 0.05, 8, true);
                this.halo = new THREE.Mesh(haloGeo, this.material);

                this.group = new THREE.Group();
                this.group.add(this.core);
                this.group.add(this.halo);
                this.group.position.copy(this.position);

                this.scene.add(this.group);

                // Dynamic Point Light
                this.light = new THREE.PointLight(0xffffff, 2, 300);
                this.group.add(this.light);
            }

            update(delta, time) {
                if (this.isGone) return;

                this.age += delta;
                const progress = this.age / this.lifespan;

                if (!this.isExploding) {
                    // --- STEP 6: 星の色の多様性 & 年齢変化 ---
                    this.updateAppearance(progress, time);

                    if (progress >= 1.0) {
                        this.explode();
                    }
                } else {
                    this.updateExplosion(delta);
                }
            }

            updateAppearance(p, time) {
                // Star Color Evolution: Blue-White -> Yellow -> Orange -> Red
                let starColor = new THREE.Color();
                if (p < 0.2) starColor.setHSL(0.55, 0.8, 0.9); // Blue-White
                else if (p < 0.6) starColor.setHSL(0.12, 1.0, 0.7); // Golden
                else if (p < 0.9) starColor.setHSL(0.08, 1.0, 0.6); // Orange
                else starColor.setHSL(0.0, 1.0, 0.5); // Deep Red (Giant Phase)

                this.material.emissive.copy(starColor);
                this.material.color.copy(starColor);
                this.light.color.copy(starColor);

                // Size Pulse & Growth
                const growth = 1.0 + p * 1.5; // Expands as it ages
                const pulse = 1.0 + Math.sin(time * 5 + this.position.x) * 0.05;
                this.group.scale.set(growth * pulse, growth * pulse, growth * pulse);

                // Slight Oscillation
                this.group.position.y = this.position.y + Math.sin(time + this.position.x) * 5;
            }

            explode() {
                this.isExploding = true;
                this.explosionTimer = 0;

                // Initial flash
                this.material.emissiveIntensity = 10.0;
                this.light.intensity = 20;

                // Create Supernova Particles
                const partGeo = new THREE.BufferGeometry();
                const partPos = new Float32Array(500 * 3);
                const partVel = [];
                for (let i = 0; i < 500; i++) {
                    partPos[i * 3] = 0; partPos[i * 3 + 1] = 0; partPos[i * 3 + 2] = 0;
                    partVel.push(new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).setLength(2 + Math.random() * 5));
                }
                partGeo.setAttribute('position', new THREE.BufferAttribute(partPos, 3));
                const partMat = new THREE.PointsMaterial({ color: 0xffffff, size: 2, transparent: true });
                this.particles = new THREE.Points(partGeo, partMat);
                this.particles.vels = partVel;
                this.group.add(this.particles);
            }

            updateExplosion(delta) {
                this.explosionTimer += delta;

                // Expanding Particles
                const positions = this.particles.geometry.attributes.position.array;
                for (let i = 0; i < 500; i++) {
                    const v = this.particles.vels[i];
                    positions[i * 3] += v.x * delta * 50;
                    positions[i * 3 + 1] += v.y * delta * 50;
                    positions[i * 3 + 2] += v.z * delta * 50;
                }
                this.particles.geometry.attributes.position.needsUpdate = true;
                this.particles.material.opacity = 1.0 - (this.explosionTimer / 2.0);

                // Core Shrinking / Disappearing
                const s = 1.0 + this.explosionTimer * 5;
                this.core.scale.set(s, s, s);
                this.material.opacity = 1.0 - (this.explosionTimer / 1.5);
                this.material.transparent = true;

                if (this.explosionTimer > 2.0) {
                    this.isGone = true;
                }
            }

            dispose() {
                this.scene.remove(this.group);
                this.core.geometry.dispose();
                this.halo.geometry.dispose();
                this.material.dispose();
                if (this.particles) {
                    this.particles.geometry.dispose();
                    this.particles.material.dispose();
                }
            }
        }

        new Simulation();
    </script>
</body>

</html>