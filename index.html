<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DEEP SEA SYMBIOSIS | Abyss Evolution</title>
    <style>
        :root {
            --deep-sea-bg: #000510;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            outline: none;
        }

        body,
        html {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--deep-sea-bg);
            color: white;
            font-family: "Optima", "Inter", "Noto Sans JP", sans-serif;
            cursor: crosshair;
        }

        #canvas-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            z-index: 10;
        }

        #intro-text {
            font-size: clamp(1rem, 4vw, 1.2rem);
            letter-spacing: 0.8rem;
            color: rgba(255, 255, 255, 0.9);
            opacity: 0;
            transition: opacity 3s ease, transform 3s ease;
            text-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
            z-index: 11;
            font-weight: 200;
            transform: translateY(10px);
        }

        #intro-text.visible {
            opacity: 0.8;
            transform: translateY(0);
        }

        .breathing {
            animation: breathe 6s ease-in-out infinite;
        }

        @keyframes breathe {

            0%,
            100% {
                opacity: 0.2;
                transform: scale(0.98);
            }

            50% {
                opacity: 0.9;
                transform: scale(1.02);
            }
        }
    </style>
</head>

<body>
    <div id="container">
        <div id="canvas-wrapper"></div>
        <div id="overlay">
            <div id="intro-text" class="breathing">闇をなぞる、生命が灯る</div>
        </div>
    </div>

    <!-- Three.js UMD Build -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        (function () {
            if (typeof THREE === 'undefined') return;

            // --- CONFIG ---
            const CONFIG = {
                maxCreatures: 150,
                segments: 28,
                trailFade: 0.07, // Subtle feedback loop
                colors: [0x00FFFF, 0xFF00FF, 0x007FFF, 0x7FFF00, 0xFFFF00]
            };

            const lerp = (a, b, t) => a + (b - a) * t;

            // --- ORGANIC CREATURE ---
            class Creature {
                constructor(x, y, color, scene) {
                    this.scene = scene;
                    this.color = new THREE.Color(color);
                    this.points = [];
                    this.energy = 1.0;
                    this.decay = 0.0015 + Math.random() * 0.002;
                    this.noiseOffset = Math.random() * 100;
                    this.speedBase = 0.04 + Math.random() * 0.06;
                    this.pulseSpeed = 2 + Math.random() * 3;

                    for (let i = 0; i < CONFIG.segments; i++) {
                        this.points.push(new THREE.Vector3(x, y, 0));
                    }

                    this.group = new THREE.Group();

                    // Core (White Light)
                    const coreGeo = new THREE.BufferGeometry().setFromPoints(this.points);
                    const coreMat = new THREE.LineBasicMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.8,
                        blending: THREE.AdditiveBlending
                    });
                    this.coreLine = new THREE.Line(coreGeo, coreMat);
                    this.group.add(this.coreLine);

                    // Aura (Volume/Color)
                    const auraGeo = new THREE.BufferGeometry().setFromPoints(this.points);
                    const auraMat = new THREE.LineBasicMaterial({
                        color: this.color,
                        transparent: true,
                        opacity: 0.3,
                        blending: THREE.AdditiveBlending
                    });
                    this.auraLine = new THREE.Line(auraGeo, auraMat);
                    this.group.add(this.auraLine);

                    this.scene.add(this.group);
                }

                update(time, flowField) {
                    const head = this.points[0];
                    const angle = flowField(head.x, head.y, time + this.noiseOffset);

                    // Main movement
                    head.x += Math.cos(angle) * this.speedBase;
                    head.y += Math.sin(angle) * this.speedBase;

                    // Organic S-curve (Wobble)
                    const wobble = Math.sin(time * 3 + this.noiseOffset) * 0.03;
                    head.x += Math.cos(angle + Math.PI / 2) * wobble;
                    head.y += Math.sin(angle + Math.PI / 2) * wobble;

                    // Elastic follow
                    for (let i = 1; i < this.points.length; i++) {
                        const p = this.points[i];
                        const prev = this.points[i - 1];
                        p.x = lerp(p.x, prev.x, 0.35);
                        p.y = lerp(p.y, prev.y, 0.35);
                        p.z = lerp(p.z, prev.z, 0.35);
                    }

                    this.energy -= this.decay;

                    // Pulsating glow
                    const pulse = (Math.sin(time * this.pulseSpeed) + 1) * 0.5;
                    const alpha = Math.max(0, this.energy);
                    this.coreLine.material.opacity = alpha * (0.4 + pulse * 0.5);
                    this.auraLine.material.opacity = alpha * (0.1 + pulse * 0.3);

                    this.coreLine.geometry.setFromPoints(this.points);
                    this.coreLine.geometry.attributes.position.needsUpdate = true;
                    this.auraLine.geometry.setFromPoints(this.points);
                    this.auraLine.geometry.attributes.position.needsUpdate = true;
                }

                isDead() { return this.energy <= 0; }
                destroy() {
                    this.scene.remove(this.group);
                    this.coreLine.geometry.dispose();
                    this.coreLine.material.dispose();
                    this.auraLine.geometry.dispose();
                    this.auraLine.material.dispose();
                }
            }

            // --- ABYSS ENGINE ---
            class AbyssEngine {
                constructor() {
                    this.container = document.getElementById('canvas-wrapper');
                    this.introText = document.getElementById('intro-text');
                    this.creatures = [];
                    this.mouse = new THREE.Vector2();
                    this.isDown = false;
                    this.time = 0;
                    this.phase = 1;

                    this.init();
                    this.animate();

                    setTimeout(() => this.introText.classList.add('visible'), 500);
                }

                init() {
                    this.scene = new THREE.Scene();
                    this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                    this.camera.position.z = 15;

                    this.renderer = new THREE.WebGLRenderer({
                        antialias: true,
                        alpha: true,
                        preserveDrawingBuffer: true
                    });
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                    this.renderer.autoClear = false;
                    this.renderer.setClearColor(0x000510, 1);
                    this.container.appendChild(this.renderer.domElement);

                    // Fade Plane (Trails)
                    const fadeGeo = new THREE.PlaneGeometry(100, 100);
                    const fadeMat = new THREE.MeshBasicMaterial({
                        color: 0x000510,
                        transparent: true,
                        opacity: CONFIG.trailFade
                    });
                    this.fadePlane = new THREE.Mesh(fadeGeo, fadeMat);
                    this.fadePlane.position.z = 5;
                    this.scene.add(this.fadePlane);

                    // Marine Snow
                    const snowCount = 3000;
                    const snowGeo = new THREE.BufferGeometry();
                    const snowPos = [];
                    for (let i = 0; i < snowCount; i++) {
                        snowPos.push(THREE.MathUtils.randFloatSpread(50), THREE.MathUtils.randFloatSpread(50), THREE.MathUtils.randFloatSpread(50));
                    }
                    snowGeo.setAttribute('position', new THREE.Float32BufferAttribute(snowPos, 3));
                    this.snow = new THREE.Points(snowGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.04, transparent: true, opacity: 0.2 }));
                    this.scene.add(this.snow);

                    // God Rays (GLSL Shader)
                    const rayGeo = new THREE.PlaneGeometry(60, 60);
                    const rayMat = new THREE.ShaderMaterial({
                        uniforms: { time: { value: 0 }, color: { value: new THREE.Color(0x007FFF) } },
                        vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
                        fragmentShader: `
                            uniform float time;
                            uniform vec3 color;
                            varying vec2 vUv;
                            void main() {
                                float alpha = (1.0 - vUv.y) * 0.15 * (0.6 + 0.4 * sin(vUv.x * 12.0 + time * 0.4));
                                alpha *= (0.8 + 0.2 * sin(time * 0.1));
                                gl_FragColor = vec4(color, alpha);
                            }
                        `,
                        transparent: true,
                        blending: THREE.AdditiveBlending,
                        side: THREE.DoubleSide
                    });
                    this.rays = new THREE.Mesh(rayGeo, rayMat);
                    this.rays.position.set(0, 20, -10);
                    this.rays.rotation.x = -Math.PI / 2.5;
                    this.scene.add(this.rays);

                    this.bind();
                }

                bind() {
                    window.addEventListener('resize', () => {
                        this.camera.aspect = window.innerWidth / window.innerHeight;
                        this.camera.updateProjectionMatrix();
                        this.renderer.setSize(window.innerWidth, window.innerHeight);
                    });

                    const onDown = (e) => {
                        this.isDown = true;
                        this.updateMouse(e);
                        if (this.phase === 1) {
                            this.phase = 2;
                            this.introText.classList.remove('visible');
                            setTimeout(() => this.introText.style.display = 'none', 3000);
                        }
                        this.spawn(5);
                    };
                    const onMove = (e) => {
                        this.updateMouse(e);
                        if (this.isDown) this.spawn(1);
                    };
                    const onUp = () => this.isDown = false;

                    window.addEventListener('mousedown', onDown);
                    window.addEventListener('mousemove', onMove);
                    window.addEventListener('mouseup', onUp);
                    window.addEventListener('touchstart', (e) => onDown(e.touches[0]));
                    window.addEventListener('touchmove', (e) => onMove(e.touches[0]));
                    window.addEventListener('touchend', onUp);
                }

                updateMouse(e) {
                    this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                    this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                }

                spawn(count) {
                    if (this.creatures.length > CONFIG.maxCreatures) return;
                    const vector = new THREE.Vector3(this.mouse.x, this.mouse.y, 0.5);
                    vector.unproject(this.camera);
                    const dir = vector.sub(this.camera.position).normalize();
                    const pos = this.camera.position.clone().add(dir.multiplyScalar(-this.camera.position.z / dir.z));

                    for (let i = 0; i < count; i++) {
                        const color = CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)];
                        this.creatures.push(new Creature(pos.x, pos.y, color, this.scene));
                    }
                }

                animate() {
                    requestAnimationFrame(() => this.animate());
                    this.time += 0.015;

                    // Final Flow Logic
                    const flow = (x, y, t) => {
                        const n = Math.sin(x * 0.2 + t) * Math.cos(y * 0.2 + t) + Math.sin(y * 0.1 + t * 0.5);
                        return n * Math.PI * 2;
                    };

                    // Manual Trail Loop
                    this.fadePlane.position.copy(this.camera.position).add(this.camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(1));
                    this.renderer.render(this.scene, this.camera);

                    for (let i = this.creatures.length - 1; i >= 0; i--) {
                        const c = this.creatures[i];
                        c.update(this.time, flow);
                        if (c.isDead()) {
                            c.destroy();
                            this.creatures.splice(i, 1);
                        }
                    }

                    this.snow.position.y -= 0.005;
                    this.snow.rotation.y += 0.0002;
                    if (this.snow.position.y < -15) this.snow.position.y = 15;
                    if (this.rays) this.rays.material.uniforms.time.value = this.time;

                    this.renderer.render(this.scene, this.camera);
                }
            }

            window.onload = () => new AbyssEngine();
        })();
    </script>
</body>

</html>