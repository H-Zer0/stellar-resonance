<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DEEP SEA SYMBIOSIS | Abyss Evolution</title>
    <style>
        :root {
            --deep-sea-bg: #000510;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            outline: none;
        }

        body,
        html {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--deep-sea-bg);
            color: white;
            font-family: "Optima", "Inter", "Noto Sans JP", sans-serif;
            cursor: crosshair;
        }

        #canvas-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            z-index: 10;
        }

        #intro-text {
            font-size: clamp(1rem, 4vw, 1.2rem);
            letter-spacing: 0.8rem;
            color: rgba(255, 255, 255, 0.9);
            opacity: 0;
            transition: opacity 3s ease, transform 3s ease;
            text-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
            z-index: 11;
            font-weight: 200;
            transform: translateY(10px);
        }

        #intro-text.visible {
            opacity: 0.8;
            transform: translateY(0);
        }

        .breathing {
            animation: breathe 6s ease-in-out infinite;
        }

        @keyframes breathe {

            0%,
            100% {
                opacity: 0.2;
                transform: scale(0.98);
            }

            50% {
                opacity: 0.9;
                transform: scale(1.02);
            }
        }
    </style>
</head>

<body>
    <div id="container">
        <div id="canvas-wrapper"></div>
        <div id="overlay">
            <div id="intro-text" class="breathing">闇をなぞる、生命が灯る</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        (function () {
            if (typeof THREE === 'undefined') return;

            // --- CONFIG ---
            const CONFIG = {
                maxCreatures: 150,
                segments: 25,
                taper: true,
                trailFade: 0.08, // Higher = shorter trails
                colors: [0x00FFFF, 0xFF00FF, 0x007FFF, 0x7FFF00, 0xFFFF00]
            };

            // --- CREATURE WITH ORGANIC RIBBON ---
            class Creature {
                constructor(x, y, color, scene) {
                    this.scene = scene;
                    this.color = new THREE.Color(color);
                    this.points = [];
                    this.velocities = [];
                    this.energy = 1.0;
                    this.decay = 0.002 + Math.random() * 0.003;
                    this.noiseOffset = Math.random() * 100;
                    this.speedBase = 0.04 + Math.random() * 0.06;

                    for (let i = 0; i < CONFIG.segments; i++) {
                        this.points.push(new THREE.Vector3(x, y, 0));
                        this.velocities.push(new THREE.Vector3());
                    }

                    // Create Ribbon Mesh (using multiple points to simulate thickness/glow)
                    // In three.js R128, MeshLine is better but since we are single-file UMD, 
                    // we'll use a group of Lines with different opacities/widths for "Glow"
                    this.group = new THREE.Group();

                    // Core (Thinner, Brighter)
                    const coreGeo = new THREE.BufferGeometry().setFromPoints(this.points);
                    const coreMat = new THREE.LineBasicMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.8,
                        blending: THREE.AdditiveBlending
                    });
                    this.coreLine = new THREE.Line(coreGeo, coreMat);
                    this.group.add(this.coreLine);

                    // Aura (Thicker, Colored)
                    const auraGeo = new THREE.BufferGeometry().setFromPoints(this.points);
                    const auraMat = new THREE.LineBasicMaterial({
                        color: this.color,
                        transparent: true,
                        opacity: 0.4,
                        blending: THREE.AdditiveBlending
                    });
                    this.auraLine = new THREE.Line(auraGeo, auraMat);
                    this.group.add(this.auraLine);

                    this.scene.add(this.group);
                }

                update(time, flowField) {
                    const head = this.points[0];
                    const angle = flowField(head.x, head.y, time + this.noiseOffset);

                    // Movement
                    head.x += Math.cos(angle) * this.speedBase;
                    head.y += Math.sin(angle) * this.speedBase;

                    // Wave motion
                    head.x += Math.sin(time * 2 + this.noiseOffset) * 0.02;
                    head.y += Math.cos(time * 2 + this.noiseOffset) * 0.02;

                    // Organic segmental flow (follow the leader with easing)
                    for (let i = 1; i < this.points.length; i++) {
                        const p = this.points[i];
                        const prev = this.points[i - 1];

                        // Elastic follow
                        p.x = lerp(p.x, prev.x, 0.25);
                        p.y = lerp(p.y, prev.y, 0.25);

                        // Tapering/Thickness simulation via line properties (simulated)
                    }

                    this.energy -= this.decay;
                    const alpha = Math.max(0, this.energy);
                    this.coreLine.material.opacity = alpha * 0.8;
                    this.auraLine.material.opacity = alpha * 0.4;

                    // Update Geometries
                    this.coreLine.geometry.setFromPoints(this.points);
                    this.coreLine.geometry.attributes.position.needsUpdate = true;
                    this.auraLine.geometry.setFromPoints(this.points);
                    this.auraLine.geometry.attributes.position.needsUpdate = true;
                }

                isDead() { return this.energy <= 0; }
                destroy() {
                    this.scene.remove(this.group);
                    this.coreLine.geometry.dispose();
                    this.coreLine.material.dispose();
                    this.auraLine.geometry.dispose();
                    this.auraLine.material.dispose();
                }
            }

            function lerp(a, b, t) { return a + (b - a) * t; }

            // --- WORLD ENGINE ---
            class AbyssEngine {
                constructor() {
                    this.container = document.getElementById('canvas-wrapper');
                    this.introText = document.getElementById('intro-text');
                    this.creatures = [];
                    this.mouse = new THREE.Vector2();
                    this.isDown = false;
                    this.time = 0;
                    this.phase = 1;

                    this.init();
                    this.animate();

                    setTimeout(() => this.introText.classList.add('visible'), 500);
                }

                init() {
                    this.scene = new THREE.Scene();
                    // No background color here for manual clear loop

                    this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                    this.camera.position.z = 15;

                    this.renderer = new THREE.WebGLRenderer({
                        antialias: true,
                        alpha: true,
                        preserveDrawingBuffer: true // Crucial for manual trails
                    });
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                    this.renderer.autoClear = false; // We clear manually
                    this.renderer.setClearColor(0x000510, 1);
                    this.container.appendChild(this.renderer.domElement);

                    // Fade Plane for Trails
                    const fadeGeo = new THREE.PlaneGeometry(100, 100);
                    const fadeMat = new THREE.MeshBasicMaterial({
                        color: 0x000510,
                        transparent: true,
                        opacity: CONFIG.trailFade
                    });
                    this.fadePlane = new THREE.Mesh(fadeGeo, fadeMat);
                    this.fadePlane.position.z = 5; // In front of background, behind creatures
                    this.scene.add(this.fadePlane);

                    // Ambient Marine Snow
                    const snowCount = 2000;
                    const snowGeo = new THREE.BufferGeometry();
                    const snowPos = [];
                    for (let i = 0; i < snowCount; i++) {
                        snowPos.push(THREE.MathUtils.randFloatSpread(50), THREE.MathUtils.randFloatSpread(50), THREE.MathUtils.randFloatSpread(50));
                    }
                    snowGeo.setAttribute('position', new THREE.Float32BufferAttribute(snowPos, 3));
                    this.snow = new THREE.Points(snowGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.04, transparent: true, opacity: 0.2 }));
                    this.scene.add(this.snow);

                    this.bind();
                }

                bind() {
                    window.addEventListener('resize', () => {
                        this.camera.aspect = window.innerWidth / window.innerHeight;
                        this.camera.updateProjectionMatrix();
                        this.renderer.setSize(window.innerWidth, window.innerHeight);
                    });

                    const onDown = (e) => {
                        this.isDown = true;
                        this.updateMouse(e);
                        if (this.phase === 1) {
                            this.phase = 2;
                            this.introText.classList.remove('visible');
                            setTimeout(() => this.introText.style.display = 'none', 3000);
                        }
                        this.spawn(5);
                    };
                    const onMove = (e) => {
                        this.updateMouse(e);
                        if (this.isDown) this.spawn(1);
                    };
                    const onUp = () => this.isDown = false;

                    window.addEventListener('mousedown', onDown);
                    window.addEventListener('mousemove', onMove);
                    window.addEventListener('mouseup', onUp);
                    window.addEventListener('touchstart', (e) => onDown(e.touches[0]));
                    window.addEventListener('touchmove', (e) => onMove(e.touches[0]));
                    window.addEventListener('touchend', onUp);
                }

                updateMouse(e) {
                    this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                    this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                }

                spawn(count) {
                    if (this.creatures.length > CONFIG.maxCreatures) return;

                    const vector = new THREE.Vector3(this.mouse.x, this.mouse.y, 0.5);
                    vector.unproject(this.camera);
                    const dir = vector.sub(this.camera.position).normalize();
                    const pos = this.camera.position.clone().add(dir.multiplyScalar(-this.camera.position.z / dir.z));

                    for (let i = 0; i < count; i++) {
                        const color = CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)];
                        this.creatures.push(new Creature(pos.x, pos.y, color, this.scene));
                    }
                }

                animate() {
                    requestAnimationFrame(() => this.animate());
                    this.time += 0.015;

                    // 1. Draw Fade Plane to create trails
                    this.fadePlane.position.copy(this.camera.position).add(this.camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(1));
                    this.renderer.render(this.scene, this.camera);

                    // 2. Update and Draw Creatures (Additive)
                    const flow = (x, y, t) => {
                        const n1 = Math.sin(x * 0.3 + t) * Math.cos(y * 0.3 + t);
                        const n2 = Math.sin(y * 0.1 + t * 0.5);
                        return (n1 + n2) * Math.PI * 2;
                    };

                    for (let i = this.creatures.length - 1; i >= 0; i--) {
                        const c = this.creatures[i];
                        c.update(this.time, flow);
                        if (c.isDead()) {
                            c.destroy();
                            this.creatures.splice(i, 1);
                        }
                    }

                    // Snow motion
                    this.snow.position.y -= 0.005;
                    if (this.snow.position.y < -15) this.snow.position.y = 15;

                    this.renderer.render(this.scene, this.camera);
                }
            }

            window.onload = () => new AbyssEngine();
        })();
    </script>
</body>

</html>