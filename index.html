<!-- DEEP SEA SYMBIOSIS: The Cycle | Final Deployment -->
<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DEEP SEA SYMBIOSIS | The Cycle</title>
    <style>
        :root {
            --accent: #00ffff;
            --bg: #000510;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-user-select: none;
            user-select: none;
        }

        body,
        html {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: var(--bg);
            font-family: "Optima", "BIZ UDPMincho", serif;
            color: white;
        }

        #canvas-container {
            position: absolute;
            inset: 0;
            z-index: 1;
        }

        /* UI Layers */
        #ui-layer {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            pointer-events: none;
            z-index: 10;
            padding: 2rem;
        }

        .pane {
            pointer-events: auto;
        }

        #top-ui {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        #title-area {
            text-align: left;
        }

        h1 {
            font-size: 1.2rem;
            letter-spacing: 0.5rem;
            color: var(--accent);
            opacity: 0.8;
            text-shadow: 0 0 10px var(--accent);
        }

        p.subtitle {
            font-size: 0.8rem;
            letter-spacing: 0.2rem;
            opacity: 0.6;
            margin-top: 0.5rem;
        }

        #controls {
            display: flex;
            gap: 1rem;
        }

        .btn-circle {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            border: 1px solid rgba(0, 255, 255, 0.3);
            background: rgba(0, 5, 16, 0.6);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: 0.3s;
        }

        .btn-circle:hover {
            border-color: var(--accent);
            box-shadow: 0 0 15px var(--accent);
        }

        .btn-circle svg {
            width: 20px;
            height: 20px;
            fill: var(--accent);
        }

        #bottom-ui {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }

        #hint-text {
            font-size: 0.9rem;
            letter-spacing: 0.3rem;
            opacity: 0.5;
            animation: breathe 4s infinite;
        }

        #draw-btn {
            padding: 1rem 3rem;
            border-radius: 2rem;
            border: 1px solid var(--accent);
            background: rgba(0, 255, 255, 0.1);
            color: var(--accent);
            font-size: 1rem;
            letter-spacing: 0.5rem;
            cursor: pointer;
            transition: 0.3s;
            text-transform: uppercase;
        }

        #draw-btn:hover {
            background: var(--accent);
            color: var(--bg);
            box-shadow: 0 0 30px var(--accent);
        }

        /* Drawing Overlay */
        #drawing-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 5, 16, 0.8);
            display: none;
            z-index: 20;
            cursor: crosshair;
        }

        #drawing-overlay.active {
            display: block;
        }

        #drawing-canvas {
            width: 100%;
            height: 100%;
        }

        #draw-instructions {
            position: absolute;
            top: 10%;
            width: 100%;
            text-align: center;
            font-size: 1rem;
            letter-spacing: 0.4rem;
            color: var(--accent);
        }

        @keyframes breathe {

            0%,
            100% {
                opacity: 0.3;
                transform: scale(0.98);
            }

            50% {
                opacity: 0.8;
                transform: scale(1);
            }
        }

        /* Sound Icon Placeholder */
        .sound-off line {
            display: none;
        }
    </style>
</head>

<body>
    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div id="top-ui" class="pane">
            <div id="title-area">
                <h1>深海のサイクル</h1>
                <p class="subtitle">SYMBIOSIS OF THE ABYSS</p>
            </div>
            <div id="controls">
                <div class="control-group">
                    <div class="btn-circle" id="reset-btn" title="Reset ecosystem">
                        <svg viewBox="0 0 24 24">
                            <path
                                d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z" />
                        </svg>
                    </div>
                    <div id="creature-count"
                        style="color: rgba(255,255,255,0.7); font-family: monospace; font-size: 12px; pointer-events: none;">
                        LIFE: 0</div>
                </div>
                <div class="btn-circle" id="sound-btn" title="Toggle Sound">
                    <svg viewBox="0 0 24 24" id="sound-icon">
                        <path
                            d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z" />
                    </svg>
                </div>
            </div>
        </div>
        <div id="bottom-ui" class="pane">
            <div id="hint-text">海は静かに、あなたの筆跡を待っている</div>
            <button id="draw-btn">生命を創る</button>
        </div>
    </div>

    <div id="drawing-overlay">
        <div id="draw-instructions">一本の線を、一息に描いてください</div>
        <canvas id="drawing-canvas"></canvas>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        (function () {
            if (typeof THREE === 'undefined') return;

            // --- CONFIG ---
            const COLORS = [0x00ffff, 0xff00ff, 0x007fff, 0x7fff00, 0xffff00];
            const MAX_CREATURES = 100;

            // --- STATE ---
            let isDrawingMode = false;
            let isMuted = true;

            // --- THREEJS BASE ---
            let scene, camera, renderer, clock;
            let creatures = [];
            let particles, godRays;

            let fadeMesh;

            function initScene() {
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
                camera.position.set(0, 0, 40);

                renderer = new THREE.WebGLRenderer({ antialias: false, alpha: false }); // Disable antialias for trail stability
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.autoClear = false; // For trails
                document.getElementById('canvas-container').appendChild(renderer.domElement);

                // Fading Quad for Trails
                const fadeGeo = new THREE.PlaneGeometry(2, 2);
                const fadeMat = new THREE.MeshBasicMaterial({ color: 0x000510, transparent: true, opacity: 0.1 });
                fadeMesh = new THREE.Mesh(fadeGeo, fadeMat);
                fadeMesh.material.depthTest = false;
                fadeMesh.material.depthWrite = false;

                clock = new THREE.Clock();
                addEnvironment();
                animate();
            }

            function addEnvironment() {
                // Marine Snow
                const count = 2000;
                const geo = new THREE.BufferGeometry();
                const pos = new Float32Array(count * 3);
                for (let i = 0; i < count * 3; i++) pos[i] = (Math.random() - 0.5) * 100;
                geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                const mat = new THREE.PointsMaterial({ color: 0x00ffff, size: 0.1, transparent: true, opacity: 0.3 });
                particles = new THREE.Points(geo, mat);
                scene.add(particles);

                // God Rays
                const rayGeo = new THREE.PlaneGeometry(100, 100);
                const rayMat = new THREE.ShaderMaterial({
                    uniforms: { uTime: { value: 0 } },
                    vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
                    fragmentShader: `
                        uniform float uTime;
                        varying vec2 vUv;
                        void main() {
                            float b = sin(vUv.x * 10.0 + uTime * 0.5) * 0.5 + 0.5;
                            float a = (1.0 - vUv.y) * 0.1 * b;
                            gl_FragColor = vec4(0.0, 0.8, 1.0, a);
                        }
                    `,
                    transparent: true, blending: THREE.AdditiveBlending, side: THREE.DoubleSide
                });
                godRays = new THREE.Mesh(rayGeo, rayMat);
                godRays.position.y = 50;
                godRays.rotation.x = Math.PI / 2.5;
                scene.add(godRays);
            }

            // --- CAMERA INTERACTION ---
            let targetRotX = 0, targetRotY = 0;
            let currentRotX = 0, currentRotY = 0;
            let targetZoom = 40, currentZoom = 40;
            let isDragging = false, lastMouseX = 0, lastMouseY = 0;

            function initInteraction() {
                window.addEventListener('mousedown', (e) => {
                    if (isDrawingMode) return;
                    isDragging = true;
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                });
                window.addEventListener('mousemove', (e) => {
                    if (!isDragging || isDrawingMode) return;
                    const dx = e.clientX - lastMouseX;
                    const dy = e.clientY - lastMouseY;
                    targetRotY += dx * 0.005;
                    targetRotX += dy * 0.005;
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                });
                window.addEventListener('mouseup', () => isDragging = false);
                window.addEventListener('wheel', (e) => {
                    if (isDrawingMode) return;
                    targetZoom = THREE.MathUtils.clamp(targetZoom + e.deltaY * 0.05, 10, 100);
                });

                // UI Events
                document.getElementById('draw-btn').onclick = () => toggleDrawingMode(true);
                document.getElementById('reset-btn').onclick = resetEcosystem;
                document.getElementById('sound-btn').onclick = toggleSound;

                initDrawingCanvas();
            }

            function updateCamera() {
                currentRotX = THREE.MathUtils.lerp(currentRotX, targetRotX, 0.05);
                currentRotY = THREE.MathUtils.lerp(currentRotY, targetRotY, 0.05);
                currentZoom = THREE.MathUtils.lerp(currentZoom, targetZoom, 0.05);

                const phi = currentRotX;
                const theta = currentRotY;
                camera.position.x = currentZoom * Math.sin(theta) * Math.cos(phi);
                camera.position.y = currentZoom * Math.sin(phi);
                camera.position.z = currentZoom * Math.cos(theta) * Math.cos(phi);
                camera.lookAt(0, 0, 0);
            }


            // --- CREATURE CLASS (Guaranteed Birth Engine) ---
            class Creature {
                constructor(points, scene) {
                    this.scene = scene;
                    this.age = 0;
                    this.state = 'BIRTH'; // BIRTH -> LIVE
                    this.birthDuration = 1.0; // Seconds to grow
                    this.waitAfterBirth = 0.5; // Stay still after growing

                    // Archetype selection
                    const types = ['fish', 'jelly', 'eel'];
                    this.type = types[Math.floor(Math.random() * types.length)];
                    this.color = new THREE.Color(COLORS[Math.floor(Math.random() * COLORS.length)]);

                    // Physics/AI
                    this.pos = points && points.length > 0 ? points[0].clone() : new THREE.Vector3((Math.random() - 0.5) * 20, (Math.random() - 0.5) * 20, 0);
                    this.vel = new THREE.Vector3((Math.random() - 0.5) * 0.1, (Math.random() - 0.5) * 0.1, (Math.random() - 0.5) * 0.1);
                    this.acc = new THREE.Vector3();
                    this.maxSpeed = this.type === 'fish' ? 0.35 : (this.type === 'eel' ? 0.2 : 0.08);

                    this.segments = this.type === 'eel' ? 40 : 20;
                    this.history = [];
                    for (let i = 0; i < this.segments; i++) this.history.push(this.pos.clone());

                    this.initMesh();
                }

                initMesh() {
                    this.geometry = new THREE.BufferGeometry();
                    const vertices = new Float32Array(this.segments * 2 * 3);
                    const uvs = new Float32Array(this.segments * 2 * 2);
                    this.geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                    this.geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));

                    this.material = new THREE.ShaderMaterial({
                        uniforms: {
                            uColor: { value: this.color },
                            uAlpha: { value: 0.0 }, // Target for fade
                            uScale: { value: 0.0 }, // Target for growth
                            uTime: { value: 0 }
                        },
                        vertexShader: `
                            uniform float uScale;
                            varying vec2 vUv;
                            void main() {
                                vUv = uv;
                                vec3 pos = position * uScale;
                                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                            }
                        `,
                        fragmentShader: `
                            uniform vec3 uColor;
                            uniform float uAlpha;
                            uniform float uTime;
                            varying vec2 vUv;
                            void main() {
                                float glow = pow(1.0 - abs(vUv.y - 0.5) * 2.0, 3.0);
                                float pulse = 0.8 + 0.2 * sin(uTime * 4.0 + vUv.x * 10.0);
                                float taper = 1.0 - vUv.x * 0.5;
                                gl_FragColor = vec4(uColor, glow * pulse * uAlpha * taper);
                            }
                        `,
                        transparent: true, blending: THREE.AdditiveBlending, side: THREE.DoubleSide, depthWrite: false
                    });

                    this.mesh = new THREE.Mesh(this.geometry, this.material);
                    this.scene.add(this.mesh);
                }

                update(time, delta, others) {
                    this.age += delta;

                    if (this.state === 'BIRTH') {
                        const progress = Math.min(this.age / this.birthDuration, 1.0);
                        this.material.uniforms.uAlpha.value = progress;
                        this.material.uniforms.uScale.value = progress;

                        if (progress >= 1.0 && this.age > (this.birthDuration + this.waitAfterBirth)) {
                            this.state = 'LIVE';
                        }
                        // Don't move during birth
                    } else {
                        // LIVE State: Standard movement
                        this.wander();
                        this.separate(others);
                        this.vel.add(this.acc);
                        this.vel.clampLength(0.01, this.maxSpeed);
                        this.pos.add(this.vel);
                        this.acc.multiplyScalar(0);

                        // Soft boundary
                        if (this.pos.length() > 60) this.acc.add(this.pos.clone().multiplyScalar(-0.001));
                    }

                    // Always update trail geometry
                    this.history.unshift(this.pos.clone());
                    if (this.history.length > this.segments) this.history.pop();

                    const attr = this.geometry.attributes.position;
                    const baseT = this.type === 'jelly' ? 0.7 : (this.type === 'eel' ? 0.3 : 0.2);

                    for (let i = 0; i < this.segments; i++) {
                        const p = this.history[i];
                        const prev = i > 0 ? this.history[i - 1] : (i < this.segments - 1 ? this.history[i + 1] : p);
                        const dir = p.clone().sub(prev).normalize();
                        const norm = new THREE.Vector3(-dir.y, dir.x, 0).normalize();

                        let t = baseT * (1.0 - i / this.segments);
                        if (this.type === 'jelly') t *= (1.0 + 0.3 * Math.sin(time * 2 + i * 0.5));

                        attr.setXYZ(i * 2, p.x + norm.x * t, p.y + norm.y * t, p.z);
                        attr.setXYZ(i * 2 + 1, p.x - norm.x * t, p.y - norm.y * t, p.z);
                    }
                    attr.needsUpdate = true;
                    this.material.uniforms.uTime.value = time;
                }

                wander() {
                    this.acc.add(new THREE.Vector3((Math.random() - 0.5) * 0.01, (Math.random() - 0.5) * 0.01, (Math.random() - 0.5) * 0.01));
                }

                separate(others) {
                    others.forEach(o => {
                        if (o === this) return;
                        const d = this.pos.distanceTo(o.pos);
                        if (d < 5.0) this.acc.add(this.pos.clone().sub(o.pos).normalize().divideScalar(d * 10));
                    });
                }

                isDead() { return this.age > 60; } // Natural death after 60s
                destroy() {
                    this.scene.remove(this.mesh);
                    this.geometry.dispose();
                    this.material.dispose();
                }
            }

            function resetEcosystem() {
                creatures.forEach(c => c.destroy());
                creatures = [];
            }

            // --- AUDIO LOGIC ---
            let audioCtx, oscillator, gainNode;
            function toggleSound() {
                if (!audioCtx) {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    oscillator = audioCtx.createOscillator();
                    gainNode = audioCtx.createGain();
                    oscillator.type = 'sine';
                    oscillator.frequency.value = 40; // Deep hum
                    gainNode.gain.value = 0.05;
                    oscillator.connect(gainNode);
                    gainNode.connect(audioCtx.destination);
                    oscillator.start();
                }

                isMuted = !isMuted;
                if (isMuted) gainNode.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
                else gainNode.gain.setTargetAtTime(0.05, audioCtx.currentTime, 0.1);

                document.getElementById('sound-icon').classList.toggle('sound-off', isMuted);
            }

            // --- DRAWING LOGIC ---
            let dCanvas, dCtx, stroke = [];
            function initDrawingCanvas() {
                dCanvas = document.getElementById('drawing-canvas');
                dCtx = dCanvas.getContext('2d');
                resizeDrawingCanvas();
                window.addEventListener('resize', resizeDrawingCanvas);

                const start = (x, y) => { stroke = [{ x: x, y: y, t: Date.now() }]; };
                const move = (x, y) => {
                    if (stroke.length === 0) return;
                    stroke.push({ x: x, y: y, t: Date.now() });
                    drawStroke();
                };
                const end = () => {
                    if (stroke.length > 5) createLifeFromStroke(stroke);
                    stroke = [];
                    toggleDrawingMode(false);
                };

                dCanvas.onmousedown = (e) => start(e.clientX, e.clientY);
                dCanvas.onmousemove = (e) => move(e.clientX, e.clientY);
                dCanvas.onmouseup = end;

                dCanvas.addEventListener('touchstart', (e) => { e.preventDefault(); start(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
                dCanvas.addEventListener('touchmove', (e) => { e.preventDefault(); move(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
                dCanvas.addEventListener('touchend', (e) => { e.preventDefault(); end(); }, { passive: false });
            }

            function resizeDrawingCanvas() {
                dCanvas.width = window.innerWidth;
                dCanvas.height = window.innerHeight;
            }

            function drawStroke() {
                dCtx.clearRect(0, 0, dCanvas.width, dCanvas.height);
                dCtx.beginPath();
                const grad = dCtx.createLinearGradient(stroke[0].x, stroke[0].y, stroke[stroke.length - 1].x, stroke[stroke.length - 1].y);
                grad.addColorStop(0, '#00ffff');
                grad.addColorStop(1, '#ffffff');
                dCtx.strokeStyle = grad;
                dCtx.lineWidth = 4;
                dCtx.lineCap = 'round';
                dCtx.lineJoin = 'round';
                dCtx.shadowBlur = 10;
                dCtx.shadowColor = '#00ffff';
                dCtx.moveTo(stroke[0].x, stroke[0].y);
                for (let i = 1; i < stroke.length; i++) dCtx.lineTo(stroke[i].x, stroke[i].y);
                dCtx.stroke();
            }

            function toggleDrawingMode(active) {
                isDrawingMode = active;
                document.getElementById('drawing-overlay').classList.toggle('active', active);
                if (!active) dCtx.clearRect(0, 0, dCanvas.width, dCanvas.height);
            }

            function createLifeFromStroke(points) {
                // Guaranteed Spawn: No filters, no early returns.
                const worldPoints = points.map(p => {
                    const vec = new THREE.Vector3((p.x / window.innerWidth) * 2 - 1, -(p.y / window.innerHeight) * 2 + 1, 0.5);
                    vec.unproject(camera);
                    const dir = vec.sub(camera.position).normalize();
                    const distance = -camera.position.z / dir.z;
                    return camera.position.clone().add(dir.multiplyScalar(distance));
                });

                // Even if points are empty, the constructor handles it by randomizing position.
                const creature = new Creature(worldPoints, scene);
                creatures.push(creature);

                // Birth FX & Log
                createBirthFlash(worldPoints[0] || new THREE.Vector3(0, 0, 0), creature.color);
                console.log(`[Birth] Total Creatures: ${creatures.length}`);
            }

            function createBirthFlash(pos, color) {
                const geo = new THREE.RingGeometry(0.1, 0.5, 32);
                const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.8, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(pos);
                mesh.lookAt(camera.position);
                scene.add(mesh);

                let s = 1;
                const animateFlash = () => {
                    s += 0.5;
                    mesh.scale.set(s, s, s);
                    mesh.material.opacity *= 0.9;
                    if (mesh.material.opacity > 0.01) requestAnimationFrame(animateFlash);
                    else {
                        scene.remove(mesh);
                        geo.dispose();
                        mat.dispose();
                    }
                };
                animateFlash();
            }


            // --- LOOP ---
            function animate() {
                requestAnimationFrame(animate);
                const delta = clock.getDelta();
                const time = clock.getElapsedTime();

                updateCamera();

                // Fading Trail Effect
                if (fadeMesh) {
                    fadeMesh.position.copy(camera.position);
                    fadeMesh.quaternion.copy(camera.quaternion);
                    fadeMesh.translateZ(-1); // Place right in front of camera
                    renderer.render(fadeMesh, camera);
                }

                if (godRays) godRays.material.uniforms.uTime.value = time;
                if (particles) {
                    particles.rotation.y += 0.001;
                    const pos = particles.geometry.attributes.position.array;
                    for (let i = 0; i < pos.length; i += 3) {
                        pos[i + 1] -= 0.02; // Sinking snow
                        if (pos[i + 1] < -50) pos[i + 1] = 50;
                    }
                    particles.geometry.attributes.position.needsUpdate = true;
                }

                // Creatures Update
                for (let i = creatures.length - 1; i >= 0; i--) {
                    const c = creatures[i];
                    c.update(time, delta, creatures);
                    if (c.isDead()) {
                        c.destroy();
                        creatures.splice(i, 1);
                    }
                }
                document.getElementById('creature-count').textContent = `LIFE: ${creatures.length}`;

                renderer.render(scene, camera);
            }

            initScene();
            initInteraction();
        })();
    </script>
</body>

</html>