<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DEEP SEA SYMBIOSIS | Resonance</title>
    <style>
        :root {
            --accent: #00ffff;
            --bg: #000814;
            --glass: rgba(0, 20, 40, 0.4);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            overflow: hidden;
        }

        body {
            background: var(--bg);
            font-family: 'Inter', system-ui, sans-serif;
            color: white;
        }

        #ui-overlay {
            position: absolute;
            inset: 0;
            z-index: 100;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 2rem;
        }

        .glass-panel {
            pointer-events: auto;
            background: var(--glass);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 12px;
            padding: 1rem;
        }

        #top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h1 {
            font-size: 1rem;
            letter-spacing: 0.3em;
            color: var(--accent);
            text-transform: uppercase;
        }

        #bottom-bar {
            display: flex;
            align-items: center;
            gap: 1rem;
            justify-content: center;
        }

        .btn {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid var(--accent);
            color: var(--accent);
            padding: 0.8rem 2rem;
            border-radius: 30px;
            cursor: pointer;
            transition: 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-weight: bold;
            pointer-events: auto;
            /* Ensure clickable */
        }

        .btn:hover {
            background: var(--accent);
            color: var(--bg);
            box-shadow: 0 0 20px var(--accent);
        }

        /* Sketch Canvas */
        #sketch-overlay {
            position: absolute;
            inset: 0;
            z-index: 200;
            background: rgba(0, 8, 20, 0.7);
            display: none;
            cursor: crosshair;
        }

        #sketch-overlay.active {
            display: block;
        }

        #sketch-canvas {
            width: 100%;
            height: 100%;
        }

        #sketch-hint {
            position: absolute;
            top: 10%;
            width: 100%;
            text-align: center;
            color: var(--accent);
            font-size: 1.2rem;
            pointer-events: none;
            letter-spacing: 0.2rem;
        }
    </style>
</head>

<body>

    <div id="ui-overlay">
        <div id="top-bar" class="glass-panel">
            <h1>Deep Sea Symbiosis</h1>
            <div id="stats" style="font-family: monospace; opacity: 0.7;">LIFE: 0</div>
        </div>
        <div id="bottom-bar">
            <button class="btn" id="spawn-btn">生命を創印する</button>
            <button class="btn" id="sound-btn">SOUND: OFF</button>
        </div>
    </div>

    <div id="sketch-overlay">
        <div id="sketch-hint">深海の生命を描いてください</div>
        <canvas id="sketch-canvas"></canvas>
    </div>

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>

    <script>
        /**
         * DEEP SEA SYMBIOSIS | Resonance Engine
         * A complex biological simulation driven by user sketches.
         */

        class Simulation {
            constructor() {
                this.initThree();
                this.initPhysics();
                this.initSketch();
                this.animate();
                this.creatures = [];
                this.isMuted = true;
            }

            // --- STEP 4: レンダリング基盤 ---
            initThree() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
                this.camera.position.set(0, 0, 100);

                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.setClearColor(0x000814);
                document.body.appendChild(this.renderer.domElement);

                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.autoRotate = true;
                this.controls.autoRotateSpeed = 0.5;

                // Post-processing
                const renderScene = new THREE.RenderPass(this.scene, this.camera);
                const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloomPass.threshold = 0.2;
                bloomPass.strength = 1.2;
                bloomPass.radius = 0.5;

                this.composer = new THREE.EffectComposer(this.renderer);
                this.composer.addPass(renderScene);
                this.composer.addPass(bloomPass);

                // Environment: Marine Snow & Infinite Abyss
                this.addEnvironment();
                this.addAbyssShader();

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    this.composer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            addEnvironment() {
                const geo = new THREE.BufferGeometry();
                const pos = new Float32Array(5000 * 3);
                for (let i = 0; i < 5000 * 3; i++) pos[i] = (Math.random() - 0.5) * 500;
                geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                const mat = new THREE.PointsMaterial({ color: 0x00ffff, size: 0.5, transparent: true, opacity: 0.3 });
                this.parts = new THREE.Points(geo, mat);
                this.scene.add(this.parts);
            }

            addAbyssShader() {
                const geo = new THREE.SphereGeometry(1000, 32, 32);
                const mat = new THREE.ShaderMaterial({
                    side: THREE.BackSide,
                    uniforms: { uTime: { value: 0 } },
                    vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
                    fragmentShader: `
                uniform float uTime;
                varying vec2 vUv;
                void main() {
                    float noise = sin(vUv.x * 10.0 + uTime) * cos(vUv.y * 10.0 + uTime);
                    vec3 color = mix(vec3(0.0, 0.02, 0.05), vec3(0.0, 0.05, 0.1), vUv.y + noise * 0.1);
                    gl_FragColor = vec4(color, 1.0);
                }
            `
                });
                this.abyss = new THREE.Mesh(geo, mat);
                this.scene.add(this.abyss);
            }
            // --- STEP 3: 物理・最適化基盤 ---
            initPhysics() {
                this.clock = new THREE.Clock();
                this.grid = new Map(); // Simple spatial hash for neighbor search
                this.gridSize = 20;
            }

            updateGrid() {
                this.grid.clear();
                this.creatures.forEach(c => {
                    const gx = Math.floor(c.position.x / this.gridSize);
                    const gy = Math.floor(c.position.y / this.gridSize);
                    const gz = Math.floor(c.position.z / this.gridSize);
                    const key = `${gx},${gy},${gz}`;
                    if (!this.grid.has(key)) this.grid.set(key, []);
                    this.grid.get(key).push(c);
                });
            }

            // --- STEP 5: UI & Audio ---
            initAudio() {
                this.audioBtn = document.getElementById('sound-btn');
                this.audioBtn.onclick = () => {
                    if (!this.audioCtx) this.setupAudioContext();
                    this.isMuted = !this.isMuted;
                    this.audioBtn.innerText = `SOUND: ${this.isMuted ? 'OFF' : 'ON'}`;
                    if (this.gainNode) this.gainNode.gain.setTargetAtTime(this.isMuted ? 0 : 0.1, this.audioCtx.currentTime, 0.1);
                };
            }

            setupAudioContext() {
                this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                this.osc = this.audioCtx.createOscillator();
                this.gainNode = this.audioCtx.createGain();
                this.osc.type = 'sine';
                this.osc.frequency.setValueAtTime(40, this.audioCtx.currentTime); // Deep hum
                this.gainNode.gain.setValueAtTime(0, this.audioCtx.currentTime);
                this.osc.connect(this.gainNode);
                this.gainNode.connect(this.audioCtx.destination);
                this.osc.start();
            }

            playSpawnSound() {
                if (!this.audioCtx || this.isMuted) return;
                const o = this.audioCtx.createOscillator();
                const g = this.audioCtx.createGain();
                o.type = 'triangle';
                o.frequency.setValueAtTime(100 + Math.random() * 200, this.audioCtx.currentTime);
                o.frequency.exponentialRampToValueAtTime(10, this.audioCtx.currentTime + 2);
                g.gain.setValueAtTime(0.1, this.audioCtx.currentTime);
                g.gain.linearRampToValueAtTime(0, this.audioCtx.currentTime + 2);
                o.connect(g);
                g.connect(this.audioCtx.destination);
                o.start();
                o.stop(this.audioCtx.currentTime + 2);
            }

            // --- STEP 1: Canvas入力 & 解析 ---
            initSketch() {
                this.initAudio();
                const overlay = document.getElementById('sketch-overlay');
                const canvas = document.getElementById('sketch-canvas');
                const ctx = canvas.getContext('2d');
                let drawing = false;
                let points = [];

                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;

                document.getElementById('spawn-btn').onclick = () => {
                    overlay.classList.add('active');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    points = [];
                };

                const getXY = (e) => {
                    if (e.touches && e.touches.length > 0) {
                        return [e.touches[0].clientX, e.touches[0].clientY];
                    }
                    return [e.clientX, e.clientY];
                };

                const start = (e) => { drawing = true; points = [getXY(e)]; };
                const move = (e) => {
                    if (!drawing) return;
                    const pos = getXY(e);
                    ctx.beginPath();
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.moveTo(points[points.length - 1][0], points[points.length - 1][1]);
                    ctx.lineTo(pos[0], pos[1]);
                    ctx.stroke();
                    points.push(pos);
                };
                const end = () => {
                    if (!drawing) return;
                    drawing = false;
                    overlay.classList.remove('active');
                    if (points.length > 5) {
                        this.generateCreature(points);
                        this.playSpawnSound();
                    }
                };

                canvas.addEventListener('mousedown', start);
                canvas.addEventListener('mousemove', move);
                window.addEventListener('mouseup', end);
                canvas.addEventListener('touchstart', start);
                canvas.addEventListener('touchmove', move);
                canvas.addEventListener('touchend', end);
            }

            // 特徴抽出 & パラメータ変換
            analyzeSketch(points) {
                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                let length = 0;
                points.forEach((p, i) => {
                    minX = Math.min(minX, p[0]); maxX = Math.max(maxX, p[0]);
                    minY = Math.min(minY, p[1]); maxY = Math.max(maxY, p[1]);
                    if (i > 0) length += Math.hypot(p[0] - points[i - 1][0], p[1] - points[i - 1][1]);
                });

                const width = maxX - minX;
                const height = maxY - minY;
                const aspect = width / Math.max(height, 1);
                const size = Math.sqrt(width * height);
                const startEndDist = Math.hypot(points[0][0] - points[points.length - 1][0], points[0][1] - points[points.length - 1][1]);
                const isClosed = startEndDist < 50;

                return { points, aspect, size, length, isClosed };
            }

            // --- STEP 2: 生物生成 ---
            generateCreature(rawPoints) {
                const features = this.analyzeSketch(rawPoints);
                const creature = new Creature(features, this.scene);
                this.creatures.push(creature);
                document.getElementById('stats').innerText = `LIFE: ${this.creatures.length}`;
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                const delta = this.clock.getDelta();
                const time = this.clock.getElapsedTime();

                if (this.abyss) this.abyss.material.uniforms.uTime.value = time * 0.1;
                if (this.parts) this.parts.rotation.y += 0.001;

                this.updateGrid();

                for (let i = this.creatures.length - 1; i >= 0; i--) {
                    const c = this.creatures[i];
                    c.update(time, delta, this.creatures, this.grid, this.gridSize);

                    // Predation Check (Step 3)
                    this.checkPredation(c, i);
                }

                this.controls.update();
                this.composer.render();
            }

            // --- STEP 3: 捕食イベント ---
            checkPredation(predator, index) {
                if (predator.isDead) return;
                this.creatures.forEach((prey, j) => {
                    if (predator === prey || prey.isDead) return;
                    // サイズ差が1.5倍以上で捕食可能
                    if (predator.scale > prey.scale * 1.5) {
                        const dist = predator.position.distanceTo(prey.position);
                        if (dist < predator.scale * 2) {
                            prey.die();
                            predator.onEat();
                        }
                    }
                });

                // クリーンアップ
                if (predator.isDead && predator.opacity <= 0) {
                    predator.destroy();
                    this.creatures.splice(index, 1);
                    document.getElementById('stats').innerText = `LIFE: ${this.creatures.length}`;
                }
            }
        }

        /**
         * CREATURE CLASS
         * 生物の定義、形状生成、挙動
         */
        class Creature {
            constructor(features, scene) {
                this.scene = scene;
                this.features = features;
                this.isDead = false;
                this.opacity = 1.0;
                this.scale = features.size * 0.05;
                this.health = 100;

                // Boids state
                this.position = new THREE.Vector3((Math.random() - 0.5) * 100, (Math.random() - 0.5) * 100, (Math.random() - 0.5) * 100);
                this.velocity = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).setLength(0.2 + Math.random() * 0.3);
                this.acceleration = new THREE.Vector3();
                this.maxSpeed = 0.5 + Math.random() * 0.5;
                this.maxForce = 0.02;

                this.initMesh();
            }

            initMesh() {
                const points = this.features.points.map(p => {
                    return new THREE.Vector3(
                        (p[0] - (window.innerWidth / 2)) * 0.1,
                        -(p[1] - (window.innerHeight / 2)) * 0.1,
                        0
                    );
                });

                const center = new THREE.Vector3();
                points.forEach(p => center.add(p));
                center.divideScalar(points.length);
                points.forEach(p => p.sub(center));

                let geo;
                if (this.features.isClosed && points.length > 10) {
                    const shape = new THREE.Shape();
                    shape.moveTo(points[0].x, points[0].y);
                    for (let i = 1; i < points.length; i++) {
                        shape.lineTo(points[i].x, points[i].y);
                    }
                    shape.closePath();

                    const extrudeSettings = {
                        steps: 1,
                        depth: this.scale * 0.5,
                        bevelEnabled: true,
                        bevelThickness: this.scale * 0.2,
                        bevelSize: this.scale * 0.2,
                        bevelSegments: 3
                    };
                    geo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
                } else {
                    const curve = new THREE.CatmullRomCurve3(points);
                    geo = new THREE.TubeGeometry(curve, 20, this.scale * 0.2, 8, false);
                }

                const colors = [0x00ffff, 0xff00ff, 0x00ffaa, 0x66ffff, 0xffaa00];
                this.color = new THREE.Color(colors[Math.floor(Math.random() * colors.length)]);

                this.material = new THREE.MeshPhongMaterial({
                    color: this.color,
                    emissive: this.color,
                    emissiveIntensity: 0.5,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });

                this.mesh = new THREE.Mesh(geo, this.material);
                this.scene.add(this.mesh);
            }

            update(time, delta, all, grid, gridSize) {
                if (this.isDead) {
                    this.opacity -= 0.02;
                    this.material.opacity = Math.max(0, this.opacity);
                    this.mesh.scale.multiplyScalar(0.98);
                    return;
                }

                this.applyBoids(all, grid, gridSize);
                this.applyBoundaries();

                this.velocity.add(this.acceleration);
                this.velocity.clampLength(0.1, this.maxSpeed);
                this.position.add(this.velocity);
                this.acceleration.multiplyScalar(0);

                // Update Mesh
                this.mesh.position.copy(this.position);
                this.mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), this.velocity.clone().normalize());

                // Organic Animation (Step 3: 流体挙動)
                const s = 1.0 + Math.sin(time * 3 + this.position.x) * 0.1;
                this.mesh.scale.set(s, s, s);
            }

            applyBoids(all, grid, gridSize) {
                const gx = Math.floor(this.position.x / gridSize);
                const gy = Math.floor(this.position.y / gridSize);
                const gz = Math.floor(this.position.z / gridSize);

                let sep = new THREE.Vector3(), ali = new THREE.Vector3(), coh = new THREE.Vector3();
                let count = 0;

                // 近傍セルのみ検索 (Step 3: 最適化)
                for (let x = -1; x <= 1; x++) {
                    for (let y = -1; y <= 1; y++) {
                        for (let z = -1; z <= 1; z++) {
                            const key = `${gx + x},${gy + y},${gz + z}`;
                            const neighbors = grid.get(key);
                            if (!neighbors) continue;
                            neighbors.forEach(o => {
                                if (o === this) return;
                                const d = this.position.distanceTo(o.position);
                                if (d < 20) {
                                    // Separation
                                    sep.add(this.position.clone().sub(o.position).divideScalar(d));
                                    // Alignment & Cohesion
                                    ali.add(o.velocity);
                                    coh.add(o.position);
                                    count++;
                                }
                            });
                        }
                    }
                }

                if (count > 0) {
                    sep.divideScalar(count).setLength(this.maxForce * 1.5);
                    ali.divideScalar(count).setLength(this.maxForce * 0.8);
                    coh.divideScalar(count).sub(this.position).setLength(this.maxForce * 0.5);
                    this.acceleration.add(sep).add(ali).add(coh);
                }

                // Random wander
                this.acceleration.add(new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).multiplyScalar(0.01));
            }

            applyBoundaries() {
                const d = 150;
                if (this.position.x > d) this.acceleration.x -= this.maxForce * 2;
                if (this.position.x < -d) this.acceleration.x += this.maxForce * 2;
                if (this.position.y > d) this.acceleration.y -= this.maxForce * 2;
                if (this.position.y < -d) this.acceleration.y += this.maxForce * 2;
                if (this.position.z > d) this.acceleration.z -= this.maxForce * 2;
                if (this.position.z < -d) this.acceleration.z += this.maxForce * 2;
            }

            onEat() {
                this.scale *= 1.1;
                this.mesh.scale.multiplyScalar(1.1);
                this.maxSpeed *= 0.95; // 重くなると遅くなる
            }

            die() {
                this.isDead = true;
            }

            destroy() {
                this.scene.remove(this.mesh);
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
            }
        }

        // Start simulation
        const sim = new Simulation();

        // Lights
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(1, 1, 1);
        sim.scene.add(light);
        sim.scene.add(new THREE.AmbientLight(0x224466));

    </script>
</body>

</html>